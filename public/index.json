[{"categories":["Shetab"],"content":"سامانه‌ی شتاب به عنوان تنها سوئیچ ملی بین بانکی کشور، سیستمی مبتنی بر کارت‌ بوده و وظیفه تبادل تراکنش‌های بین بانکی و اعمال مقررات بانک مرکزی به عنوان مقام ناظر را بر عهده دارد و سطح گستردگی این سامانه شامل کلیه بانک‌های کشور است که با اتصال به چند سوئیچ برون‌مرزی، کل تراکنش‌های کارتی کشور را پوشش می‌دهد.\nسامانه‌ی شتاب جهت تبادل پیام‌ها و تراکنش‌های مالی از استاندارد ISO8583 استفاده کرده و قابلیت پشتیبانی از سه ویرایش این استاندارد که در سال‌های 1987، 1993 و 2003 ارائه گردیده است را دارد. بانک مرکزی در سال 1392 با ارائه نسخه 7 شتاب بانک‌ها را ملزم به استفاده از ویرایش 2003 این استاندارد کرده است. شتاب وظیفه انتقال امن اطلاعات و داده‌های مربوط به تراکنش‌های ‌مالی و غیرمالی به بانک‌های صادرکننده و یا پذیرنده را دارد. این مرکز با استفاده از سخت افزارها، نرم افزارها و شبکه‌ی ارتباطی خود، پیام‌ها و داده‌های اخذ شده از اعضا را پذیرش کرده، آن‌ها را ثبت، مسیریابی و به بانک‌های صادرکننده یا پذیرنده ارسال می‌نماید. نتیجه این اقدامات دریافت خدمات مبتنی بر کارت توسط دارندگان کارت بانک‌ها از تجهیزات سایر بانک‌ها می‌باشد. شتاب برای نظارت بیشتر بر شبکه‌ی بانکی با ارتباط با مرکز کنترل و نظارت اعتباری (مکنا) کلیه سوابق مشتریان و قوانین بالا دستی را کنترل و بر تراکنش‌های تبادلی در این شبکه نظارت دارد.\n","date":"Jun 3, 2020","img":"","permalink":"/posts/shetab-info/","series":[],"tags":["شتاب","Shetab"],"title":"سامانه شتاب"},{"categories":["SQLServer"],"content":"یکی از موارد پُرکاربرد در مهندسی معکوس نرم‌افزارهای دارای بانک اطلاعاتی جستجوی یک مقدار در کل جدول‌های یک بانک اطلاعاتی است.\nبه این منظور می‌توان از کد زیر استفاده نمود:\n1DECLARE@SearchStrnvarchar(100)2SET@SearchStr=\u0026#39;## YOUR STRING HERE ##\u0026#39;34CREATETABLE#Results(ColumnNamenvarchar(370),ColumnValuenvarchar(3630))56SETNOCOUNTON78DECLARE@TableNamenvarchar(256),9@ColumnNamenvarchar(128),10@SearchStr2nvarchar(110)1112SET@TableName=\u0026#39;\u0026#39;1314SET@SearchStr2=QUOTENAME(\u0026#39;%\u0026#39;+@SearchStr+\u0026#39;%\u0026#39;,\u0026#39;\u0026#39;\u0026#39;\u0026#39;)1516WHILE@TableNameISNOTNULL17BEGIN18SET@ColumnName=\u0026#39;\u0026#39;19SET@TableName=20(21SELECTMIN(QUOTENAME(TABLE_SCHEMA)+\u0026#39;.\u0026#39;+QUOTENAME(TABLE_NAME))22FROMINFORMATION_SCHEMA.TABLES23WHERETABLE_TYPE=\u0026#39;BASE TABLE\u0026#39;24ANDQUOTENAME(TABLE_SCHEMA)+\u0026#39;.\u0026#39;+QUOTENAME(TABLE_NAME)\u0026gt;@TableName25ANDOBJECTPROPERTY(26OBJECT_ID(27QUOTENAME(TABLE_SCHEMA)+\u0026#39;.\u0026#39;+QUOTENAME(TABLE_NAME)28),\u0026#39;IsMSShipped\u0026#39;29)=030)3132WHILE(@TableNameISNOTNULL)AND(@ColumnNameISNOTNULL)33BEGIN34SET@ColumnName=35(36SELECTMIN(QUOTENAME(COLUMN_NAME))37FROMINFORMATION_SCHEMA.COLUMNS38WHERETABLE_SCHEMA=PARSENAME(@TableName,2)39ANDTABLE_NAME=PARSENAME(@TableName,1)40ANDDATA_TYPEIN(\u0026#39;char\u0026#39;,\u0026#39;varchar\u0026#39;,\u0026#39;nchar\u0026#39;,\u0026#39;nvarchar\u0026#39;,\u0026#39;int\u0026#39;,\u0026#39;decimal\u0026#39;)41ANDQUOTENAME(COLUMN_NAME)\u0026gt;@ColumnName42)4344IF@ColumnNameISNOTNULL45BEGIN46INSERTINTO#Results47EXEC48(49\u0026#39;SELECT \u0026#39;\u0026#39;\u0026#39;+@TableName+\u0026#39;.\u0026#39;+@ColumnName+\u0026#39;\u0026#39;\u0026#39;, LEFT(\u0026#39;+@ColumnName+\u0026#39;, 3630) FROM \u0026#39;+@TableName+\u0026#39; (NOLOCK) \u0026#39;+50\u0026#39; WHERE \u0026#39;+@ColumnName+\u0026#39; LIKE \u0026#39;+@SearchStr251)52END53END54END5556SELECTColumnName,ColumnValueFROM#Results5758DROPTABLE#Resultsهمچنین می‌توان به منظور قابلیت استفاده مجدد، کد بالا را به صورت Stored Procedure نیز پیاده‌سازی نمود:\n1CREATEPROCSearchAllTables2(3@SearchStrnvarchar(100)4)5AS6BEGIN7CREATETABLE#Results(ColumnNamenvarchar(370),ColumnValuenvarchar(3630))89SETNOCOUNTON1011DECLARE@TableNamenvarchar(256),12@ColumnNamenvarchar(128),13@SearchStr2nvarchar(110)1415SET@TableName=\u0026#39;\u0026#39;16SET@SearchStr2=QUOTENAME(\u0026#39;%\u0026#39;+@SearchStr+\u0026#39;%\u0026#39;,\u0026#39;\u0026#39;\u0026#39;\u0026#39;)1718WHILE@TableNameISNOTNULL19BEGIN20SET@ColumnName=\u0026#39;\u0026#39;21SET@TableName=22(23SELECTMIN(QUOTENAME(TABLE_SCHEMA)+\u0026#39;.\u0026#39;+QUOTENAME(TABLE_NAME))24FROMINFORMATION_SCHEMA.TABLES25WHERETABLE_TYPE=\u0026#39;BASE TABLE\u0026#39;26ANDQUOTENAME(TABLE_SCHEMA)+\u0026#39;.\u0026#39;+QUOTENAME(TABLE_NAME)\u0026gt;@TableName27ANDOBJECTPROPERTY(28OBJECT_ID(29QUOTENAME(TABLE_SCHEMA)+\u0026#39;.\u0026#39;+QUOTENAME(TABLE_NAME)30),\u0026#39;IsMSShipped\u0026#39;31)=032)3334WHILE(@TableNameISNOTNULL)AND(@ColumnNameISNOTNULL)35BEGIN36SET@ColumnName=37(38SELECTMIN(QUOTENAME(COLUMN_NAME))39FROMINFORMATION_SCHEMA.COLUMNS40WHERETABLE_SCHEMA=PARSENAME(@TableName,2)41ANDTABLE_NAME=PARSENAME(@TableName,1)42ANDDATA_TYPEIN(\u0026#39;char\u0026#39;,\u0026#39;varchar\u0026#39;,\u0026#39;nchar\u0026#39;,\u0026#39;nvarchar\u0026#39;,\u0026#39;int\u0026#39;,\u0026#39;decimal\u0026#39;)43ANDQUOTENAME(COLUMN_NAME)\u0026gt;@ColumnName44)4546IF@ColumnNameISNOTNULL47BEGIN48INSERTINTO#Results49EXEC50(51\u0026#39;SELECT \u0026#39;\u0026#39;\u0026#39;+@TableName+\u0026#39;.\u0026#39;+@ColumnName+\u0026#39;\u0026#39;\u0026#39;, LEFT(\u0026#39;+@ColumnName+\u0026#39;, 3630) FROM \u0026#39;+@TableName+\u0026#39; (NOLOCK) \u0026#39;+52\u0026#39; WHERE \u0026#39;+@ColumnName+\u0026#39; LIKE \u0026#39;+@SearchStr253)54END55END56END5758SELECTColumnName,ColumnValueFROM#Results59DROPTABLE#Results60END","date":"Feb 9, 2020","img":"","permalink":"/posts/sql-server-search-in-tables/","series":[],"tags":["SQLServer"],"title":"جستجو در همه جدول‌ها در SQL Server"},{"categories":["DotNet","CSharp","SQLServer"],"content":"SQL Server به منظور ارتقا در مدل برنامه‌نویسی بانک اطلاعاتی خود از نسخه 2005 تکنولوژی SQL CLR را معرفی نمود. این تکنولوژی همچنین با اسامی CLR Integrated ،CLR Enabled و CLR Embedded نیز شناخته می‌شود. هدف آن این است که شما بتوانید اشیاء بانک اطلاعاتی از قبیل Stored Procedure ،Function ،Trigger را با استفاده از CSharp و یا VB ایجاد کرده و آن را در SQL Server مورد استفاده قرار دهید.\nتکنولوژی SQL CLR با میزبانی کردن از (dotNET Common Language Runtime) یا همان محیط زمان اجرای dotNET در SQL Server، به مدیران بانک اطلاعاتی اجازه می‌دهد تا از قابلیت‌های موجود در dotNET برای تعریف اشیاء بانک اطلاعاتی استفاده کنند. این قابلیت توسط فضاهای نام System.Data ،System.Data.Sql و Microsoft.SqlServer.Server که در اسمبلی System.Data.dll در dotNET قرار داده شده‌اند، پشتیبانی می‌گردند. ایجاد اشیاء بانک اطلاعاتی با استفاده از امکان SQL CLR، طی مراحل زیر ممکن می‌گردند:\n پیاده‌سازی کدها در CSharp یا VB در dotNET و Compile آن بارگذاری و اجرای کد Compile شده در مرحله قبل در SQL Server  فعال سازی امکان SQL CLR در بانک اطلاعاتی ایجاد اسمبلی از کد مزبور در بانک اطلاعاتی ایجاد شی بانک اطلاعاتی از اسمبلی مرحله قبل     پیاده‌سازی کدها در CSharp یا VB در dotNET و Compile آن به عنوان مثال کد مورد نظر خود را در کلاسی با نام StoredProcedures و در تابع SP1 نوشته و آن را Compile می‌کنیم. کد Compile شده را (StoredProcedures.dll) باید در مرحله بعد در SQL Server بارگذاری کنیم. البته کد زیر یک مثال hello world بوده و تنها به منظور آشنایی با نحوه انجام کار می‌باشد. از تمامی قابلیت‌ها و کلاس‌های موجود در dotNET می‌توان در این کلاس استفاده نمود.\n1using System; 2using System.Data; 3using Microsoft.SqlServer.Server; 4using System.Data.SqlTypes; 56public class StoredProcedures 7{ 8[Microsoft.SqlServer.Server.SqlProcedure] 9public static void SP1() 10{ 11SqlContext.Pipe.Send(\u0026#34;Hello world!\\n\u0026#34;); 12} 13} فعال‌سازی امکان CLR SQL در بانک اطلاعاتی امکان CLR SQL در SQL Server به صورت پیش فرض غیرفعال است و برای فعال‌سازی آن باید کد زیر را اجرا کرد:\n1sp_configure\u0026#39;show advanced options\u0026#39;,12RECONFIGURE3GO45sp_configure\u0026#39;clr enabled\u0026#39;,16RECONFIGURE7GO89sp_configure\u0026#39;show advanced options\u0026#39;,010RECONFIGURE11GOبرای غیرفعال‌سازی هم کد زیر را باید اجرا نمود:\n1sp_configure\u0026#39;show advanced options\u0026#39;,12RECONFIGURE3GO45sp_configure\u0026#39;clr enabled\u0026#39;,06RECONFIGURE7GO89sp_configure\u0026#39;show advanced options\u0026#39;,010RECONFIGURE11GOبرای اینکه فعال یا غیرفعال بودن SQL CLR را در SQL SERVER بررسی نماییم باید کد زیر را اجرا نمود:\n1SELECTname2,CAST(valueASint)ASvalue_configured3,CAST(value_in_useASint)ASvalue_in_use4FROMsys.configurations5WHEREname=\u0026#39;clr enabled\u0026#39;ایجاد اسمبلی در بانک اطلاعاتی گام بعدی ایجاد اسمبلی در بانک اطلاعاتی از روی کد Compile شده است.\n1CREATEASSEMBLYQClrIntegration2FROM\u0026#39;H:\\Clr\\StoredProcedures.dll\u0026#39;3WITHPermission_set=safe4GOبا توجه به کدی که نوشته‌ایم و برای کنترل دسترسی کد CLR به دیگر کدها از PERMISSION_SET استفاده می‌گردد:\n ویژگی SAFE به اسمبلی‌ها اجازه می‌دهد که تنها محاسبات محلی و دسترسی به فایل‌های محلی را داشته باشد. ویژگی EXTERNAL_ACCESS مشابه ویژگی قبلی با این تفاوت که اسمبلی می‌تواند به منابع شبکه دسترسی داشته باشد. ویژگی UNSAFE اجازه دسترسی نامحدود به منابع و کدهای غیر از dotNet و مدیریت نشده (Unmanaged Code) را هم می‌دهد.  برای استفاده از ویژگی UNSAFE باید ویژگی اعتماد (trustworthy) را در بانک اطلاعاتی فعال نمود. این ویژگی مشخص می‌کند که بانک اطلاعاتی به کدهای بیرونی اعتماد دارد (البته توصیه نمی‌شود). در غیر این صورت با فعال‌سازی خصوصیت UNSAFE خطا اعلام می‌شود.\n1ALTERDATABASEDB_NAME2SETtrustworthyON3GOبه طور کلی فعال کردن استفاده از SQL CLR سطح حملات به SQL Server را وسیع‌تر می‌کند و آن را از نظر اسمبلی‌های غیر عمدی و مخرب در معرض خطر قرار می‌دهد. با توجه به ضرورت استفاده از SQL CLR بسیاری از چک لیست‌های امنیتی فقط اسمبلی‌های ایجاد شده با دسترسی SAFE را مجاز می‌دانند و اسمبلی‌های ایجاد شده با دسترسی‌های UNSAFE و EXTERNAL_ACCESS را خطرناک می‌شمارند.\nایجاد شی بانک اطلاعاتی از اسمبلی مرحله قبل حال می‌توان از اسمبلی ایجاد شده در مرحله قبل برای ایجاد Stored Procedure و یا Function مورد نظر استفاده نمود. چون در مرحله قبل ما کلاسی از نوع Stored Procedure ایجاد کردیم، در SQL Server نیز برای استفاده از آن یک Stored Procedure ایجاد می‌کنیم.\n1CREATEPROCEDUREhello2AS3EXTERNALNAMEhelloworld.StoredProcedures.SP14GOبا اجرای Stored Procedure، کد نوشته شده در تابع sp1 اجرا می‌گردد:\n1EXEChello23-- Hello world! برای حذف ابتدا باید شی‌هایی که ارجاعی از اسمبلی حذف و سپس خود اسمبلی حذف گردد:\n1DROPPROCEDUREhello2GO34DROPASSEMBLYhelloworld5GO","date":"Feb 7, 2020","img":"","permalink":"/posts/sql-server-clr/","series":[],"tags":["SQLServer","CLR","CSharp","DotNet","SQL CLR","CLR Integrated","CLR Embedded"],"title":"استفاده از CLR در SQL Server"},{"categories":["DotNet","CSharp"],"content":"برای ایجاد و استفاده از UUID در زبان برنامه‌نویسی CSharp از ساختار Guid موجود در کتابخانه System استفاده می‌شود.\nبرای ایجاد که یک Guid در زبان برنامه‌نویسی CSharp می توان از کد زیر استفاده نمود:\n1public static Guid NewGuid() 2{ 3return Guid.NewGuid(); 4} guid ایجاد شده در این روش از نوع و نسخه چهارم UUID است و به صورت تصادفی تولید می‌شود. برای تولید guid به صورت ترتیبی می‌توان از کد زیر استفاده نمود:\n1public static Guid NewSequentialGuid() 2{ 3var uid = Guid.NewGuid().ToByteArray(); 4var binDate = BitConverter.GetBytes(DateTime.UtcNow.Ticks); 56var secuentialGuid = new byte[uid.Length]; 78secuentialGuid[0] = uid[0]; 9secuentialGuid[1] = uid[1]; 10secuentialGuid[2] = uid[2]; 11secuentialGuid[3] = uid[3]; 12secuentialGuid[4] = uid[4]; 13secuentialGuid[5] = uid[5]; 14secuentialGuid[6] = uid[6]; 1516// set the first part of the 8th byte to \u0026#39;1100\u0026#39; so  17// later we\u0026#39;ll be able to validate it was generated by us  1819secuentialGuid[7] = (byte)(0xc0 | (0xf \u0026amp; uid[7])); 2021// the last 8 bytes are sequential,  22// it minimizes index fragmentation  23// to a degree as long as there are not a large  24// number of Secuential-Guids generated per millisecond  2526secuentialGuid[9] = binDate[0]; 27secuentialGuid[8] = binDate[1]; 28secuentialGuid[15] = binDate[2]; 29secuentialGuid[14] = binDate[3]; 30secuentialGuid[13] = binDate[4]; 31secuentialGuid[12] = binDate[5]; 32secuentialGuid[11] = binDate[6]; 33secuentialGuid[10] = binDate[7]; 3435return new Guid(secuentialGuid); 36} برای بررسی رشته‌ای که حاوی guid است به ساختار guid می‌توان از کد زیر استفاده نمود:\n1public static bool IsGuid(string guidString) 2{ 3return Guid.TryParse(guidString, out _); 4} برای بررسی اینکه آیا مقدار guid مورد نظرتان یک guid خالی است یا خیر می‌توان از کد زیر استفاده نمود:\n1public static bool IsEmptyGuid(Guid guid) 2{ 3return guid == Guid.Empty; 4} ","date":"Feb 6, 2020","img":"","permalink":"/posts/uuid-guid-csharp/","series":[],"tags":["UUID","GUID","CSharp","DotNet"],"title":"کار با UUID در CSharp"},{"categories":["DotNet","CSharp"],"content":"برای کار با آدرس‌های IPv4 و IPv6 در CSharp از کتابخانه System.Net و کلاس IPAddress استفاده می‌شود.\nبه منظور اعتبارسنجی آدرس‌های IP می‌توان از کد زیر استفاده نمود:\n1public static bool IsValidIp(string address) 2{ 3return IPAddress.TryParse(address, out _); 4} به منظور تشخیص نسخه‌ی آدرس‌های IP می‌توان از کد زیر استفاده نمود:\n1public static IpVersion GetIpVersion(string address) 2{ 3if (IPAddress.TryParse(address, out var ipAddress)) 4{ 5if(ipAddress.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork) 6{ 7return IpVersion.IPv4; 8} 9else if(ipAddress.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6) 10{ 11return IpVersion.IPv6; 12} 13} 1415return IpVersion.Unknown; 16} 1718public enum IpVersion 19{ 20Unknown = -1, 21IPv4, 22IPv6 23} آدرس Loopback یک آدرس IP ویژه است که برای آزمایش کارت‌های شبکه، ارتباطات و انتقال در یک کارت شبکه محلی و برنامه‌های کاربردی استفاده می‌شود. این آدرس IP مربوط به Loopback Interface نرم‌افزار کارت شبکه است که هیچ سخت‌افزاری با آن ارتباط ندارد و نیازی به اتصال فیزیکی به شبکه ندارد. برای تشخیص اینکه یک IP از نوع Loopback است یا خیر می‌توان از کد زیر استفاده نمود:\n1public static bool IsLoopback(string address) 2{ 3if (address == \u0026#34;localhost\u0026#34;) 4return true; 56if (IPAddress.TryParse(address, out var ipAddress)) 7{ 8if (ipAddress == IPAddress.Loopback || ipAddress == IPAddress.IPv6Loopback) 9return true; 10} 1112return false; 13} ","date":"Jan 4, 2020","img":"","permalink":"/posts/ip-csharp/","series":[],"tags":["IP","IPHelper","CSharp","DotNet"],"title":"کار با آدرس‌های IP در CSharp"},{"categories":["SQLServer"],"content":"با توجه به نسخه SQL Server روش جستجو و بازگرداندن لیستی از تمام جدول‌های ایجاد شده توسط کاربر کمی متفاوت است. در این مطلب به طور خلاصه پرس‌و‌جوهایی را بررسی خواهیم کرد که می‌توانند برای بازیابی لیست جدول‌ها در همه نسخه‌ها استفاده شوند.\nنسخه 2000 برای نسخه‌های قدیمی‌تر SQL Server (مانند SQL Server 2000، اگرچه این روش در SQL Server 2005 برای سازگاری با نسخه‌های قبلی نیز پشتیبانی می‌شود)، باید از یک View به نام SYS.SYSOBJECTS استفاده نمایید. این View شامل یک ردیف برای هر شی می‌باشد که در بانک اطلاعاتی ایجاد شده است، از جمله Viewها، stored procedureها و جدول‌ها. جدول‌هایی که کاربر ایجاده کرده است نیز قابل تفکیک از جدول‌های سیستمی هستند.\nدر SYSOBJECTS ستون‌های دیگری نیز وجود دارد زیرا باید اطلاعاتی در مورد هر چیزی که در طول زمان به بانک اطلاعاتی اضافه شده است را در خود نگهداری نماید. بنابراین، برای یافتن لیستی از جدول‌های ایجاد شده توسط کاربر (و تفکیک آن از جدول‌های سیستم)، باید نتایجی را پیدا کنیم که در آن ستون xtype (که نوع شی را برای آن ردیف مشخص می‌کند) برابر با مقدار U است که به معنای جدول‌های کاربر است. دستور TSQL حاصل باید به شکل زیر باشد:\n1SELECT2*3FROM4SYSOBJECTS5WHERE6xtype=\u0026#39;U\u0026#39;;7GOاز آنجایی که SYSOBJECTS بخشی از فضای نام SYS است، هنگام پرس‌و‌جو از SYSOBJECTS، تعیین اینکه SYSOBJECTS بخشی از فضای نام سراسری SYS است، غیر ضروری است، بنابراین می‌توانیم آن را همانطور که در مثال بالا نشان داده شده است حذف نماییم.\nمثال بالا لیستی از نتایج تمامی جدول‌ها ایجاد شده توسط کاربر را باز می‌گرداند. از آنجایی که تعداد ستون‌‌هایی که هنگام پرس‌و‌جو از همه ستون‌ها بازگردانده می‌شود بسیار زیاد است، ممکن است بخواهید نتایج را تنها با مشاهده ستون نام و cdate (تاریخ ایجاد) محدود کنید:\n1SELECT2name,3crdate4FROM5SYSOBJECTS6WHERE7xtype=\u0026#39;U\u0026#39;;8GOنسخه 2005 به بالا فهرست کردن نام تمام جدول‌ها در SQL Server در نسخه‌های 2005 به بالا با استفاده از یک View به نام INFORMATION_SCHEMA امکان‌پذیر است که به طور خودکار در SQL Server ساخته می‌شود. این View به شما این امکان را می‌دهد که به راحتی طیف گسترده‌ای از metadata از اشیاء موجود در SQL Server را مشاهده نمایید از جمله اطلاعاتی در مورد ستون‌ها، stored procedureها، و حتی جدول‌ها. در هنگام استفاده از این View چهار ستون بازگردانده می‌شود، که مهمترین ستون آن TABLE_TYPE است که تعیین می‌کند موجودیت آن سطر یک جدول یا یک View است.\nبرای برگرداندن همه جدول‌ها و Viewها در یک پرس‌و‌جو، عبارت TSQL زیر را اجرا کنید:\n1SELECT2*3FROM4INFORMATION_SCHEMA.TABLES;5GOبرای برگرداندن همه جدول‌ها و Viewهای یک بانک اطلاعاتی در یک پرس‌و‌جو، عبارت TSQL زیر را اجرا کنید:\n1SELECT2*3FROM4databaseName.INFORMATION_SCHEMA.TABLES;5GOاگر می‌خواهید فقط جدول‌های کاربر را مشاهده نمایید عبارت TSQL زیر را اجرا کنید:\n1SELECT2*3FROM4databaseName.INFORMATION_SCHEMA.TABLES5WHERE6TABLE_TYPE=\u0026#39;BASE TABLE\u0026#39;;7GO","date":"Aug 1, 2019","img":"","permalink":"/posts/sql-server-show-all-tables/","series":[],"tags":["SQLServer"],"title":"نمایش لیست همه جدول‌ها در SQL Server"},{"categories":null,"content":"من آرمان حسن پور هستم. از سال 1390 شروع به برنامه‌نویسی کردم. با زبان‌های برنامه‌نویسی زیادی کار کردم ولی بیشتر از زبان، توانایی حل مسئله برام ارزشمند بوده و هست. بیشتر فعالیتم در حوزه‌های مالی و بانکی بوده و همچنین در مدیریت بانک‌های اطلاعاتی دارای مهارت هستم. علاقه‌مند به یادگیری و کسب مهارت در حوزه‌های جدید فناوری اطلاعات هستم و تلاش می‌کنم که خودمو به روز نگه داشته باشم.\n","date":"Feb 28, 2019","img":"","permalink":"/about/","series":null,"tags":null,"title":"در مورد من"},{"categories":["Oracle"],"content":"در برخی از سناریوها نیاز به نمایش خروجی چند مقدار به صورت یک مقدار با یک جداکننده مانند کاما داریم. در Oracle می‌توان از تابع LISTAGG برای تبدیل نتایج پرس‌و‌جو به صورت یک مقدار جداشده با کاما استفاده نمود.\nبه طور مثال پرس‌و‌جوی زیر نام قاره‌ها را از جدول regions باز می‌گرداند.\n1SELECTregion_name2FROMregions;نتیجه:\n1REGION_NAME 2------------------------ 3Americas 4Asia 5Middle East and Africa این پرس‌و‌جو چهار سطر مختلف به عنوان نتیجه را باز می‌گرداند. اما اگر بخواهیم این چهار سطر را به صورت یک مقدار جدا شده با کاما نمایش دهیم می‌توانیم آن را به صورت زیر انجام دهیم:\n1SELECTLISTAGG(region_name,\u0026#39;, \u0026#39;)2FROMregions;نتیجه:\n1LISTAGG(LAST_NAME,\u0026#39;,\u0026#39;) 2----------------------------------------------- 3Europe, Americas, Asia, Middle East and Africa تابع LISTAGG دو مقدار را به عنوان ورودی دریافت می‌نماید. مقدار اول نام ستون و مقدار دوم جدا کننده مورد نظر می‌باشد که در این مثال کاراکتر کاما است. مقدار دوم اختیاری است و اگر داده نشود بدون جدا کننده مقادیر بهم چسبانده می‌شوند.\nامکان استفاده از عبارت DISTINCT در تابع LISTAGG به منظور حذف مقادیر تکراری نیز وجود دارد.\n1SELECTLISTAGG(DISTINCTregion_id,\u0026#39;,\u0026#39;)2FROMcountriesنتیجه:\n1LISTAGG(DISTINCT region_id, \u0026#39;,\u0026#39;) 2-------------------------------------------- 31,2,3,4 به منظور مرتب سازی نتایج در تابع LISTAGG می‌توان از عبارت WITHIN GROUP (ORDER BY\u0026hellip;) استفاده نمود.\n1SELECTLISTAGG(region_name,\u0026#39;,\u0026#39;)WITHINGROUP(ORDERBYregion_nameASC)2FROMregions;نتیجه:\n1LISTAGG(region_name, \u0026#39;,\u0026#39;) 2-------------------------------------------- 3Americas,Asia,Europe,Middle East and Africa از تابع LISTAGG می توان در یک پرس‌و‌جو گروه‌بندی شده نیز استفاده نمود.\n1SELECT2region_id,3LISTAGG(country_id,\u0026#39;, \u0026#39;)WITHINGROUP(ORDERBYcountry_idASC)AS\u0026#34;Countries\u0026#34;4FROMcountries5GROUPBYregion_id6ORDERBYregion_id;نتیجه:\n1REGION_ID\tCountries 2------------------------------------------------ 31\tBE, CH, DE, DK, FR, IT, NL, UK 42\tAR, BR, CA, MX, US 53\tAU, CN, HK, IN, JP, SG 64\tEG, IL, KW, NG, ZM, ZW ","date":"Feb 5, 2019","img":"","permalink":"/posts/oracle-lisagg/","series":[],"tags":["Oracle","LISTAGG","Comma Separated List"],"title":"نمایش نتایج پرس‌و‌جوها به صورت یک مقدار جداشده با کاما در Oracle"},{"categories":["General","UML"],"content":"ایجاد مدل و مدل‌سازی برای بررسی دقیق انواع مختلف سیستم‌های نرم‌افزاری در مقیاس کوچک و بزرگ به کار می‌آید. با ساختن مدل این امکان به شما داده می‌شود با ابعاد مختلف پروژه قبل از ساخت آشنا شوید. گاهی در پروژه‌های بزرگ به دلیل پیچیدگی بیش از حد نمی‌شود سیستم را از جنبه‌های مختلف سنجید. بنابراین برای فهم کامل سیستم، یافتن و نمایش ارتباط بین بخش‌های مختلف آن، به مدل‌سازی می‌پردازیم. UML زبانی برای مدل‌سازی یا ایجاد نقشه‌ی تولید نرم‌افزار است.\nدر دهه‌ی 1980، تعداد رو به رشدی از سازمان‌ها برای ایجاد برنامه‌های خود، شروع به استفاده از برنامه نویسی شی‌گرا (OOP) نمودند. بدین ترتیب فقدان یک فرایند تحلیل و طراحی شی‌گرا استاندارد کاملا احساس گردید. بسیاری از متدولوژیست‌ها مثل Booch، Rumbaugh و Jacobsob – شخصا اقدام به تولید فرایندهای مجزا برای پاسخگویی به این نیاز نموده بودند. هر فرایند دارای نشان‌گذاری یا زبان خاص خود بود (به صورت شکل‌های هندسی مصور)، تا نتایج تحلیل و طراحی را به مخاطب بفهماند. تا اوایل دهه‌ی 1990، سازمان‌های مختلف، و حتی بخش‌های موجود در درون همان سازمان‌ها، فرایندها و نشان‌گذاری‌های خاص خود را مورد استفاده قرار می‌دادند. در عین حال، این سازمان‌ها همچنین خواهان استفاده از ابزارهای نرم‌افزاری بودند که فرایند‌های خاص آن‌ها را پشتیبانی نمایند. فروشندگان نرم‌افزار دریافتند که فراهم نمودن ابزار مناسب برای تعداد زیادی از این پیاده‌سازی‌ها کار بسیار دشواری است. بدیهی بود که یک نشان‌گذاری و پیاده‌سازی استاندارد مورد نیاز بود. در سال 1994، James Rumbaugh در شرکت نرم‌افزاری Rational (که بعدها بخشی از IBM شد) به Grady Booch ملحق گردید، و هر دو فعالیت خود را در جهت یکسان‌سازی پیاده‌سازی‌های متداول آغاز نمودند. به زودی Ivar Jacobson نیز به آن‌ها ملحق شد. در سال 1996، این گروه نسخه‌های اولیه UML را به جامعه‌ی مهندسی نرم‌افزار عرضه کردند و خواهان اعلام نتیجه از سوی آن‌ها شدند. در همان زمان، سازمانی به نام گروه مدیریت شی (OMG) فراخوانی برای یک زبان مدل‌سازی مشترک پیشنهاد داده بود. OMG یک سازمان غیر‌انتفاعی بود که استاندارد‌سازی تکنولوژی‌های شی‌گرا با انتشار راهبردها و مشخصه‌هایی از قبیل UML ترویج و ترقی داد. شرکت‌های متعددی از جمله Microsoft، Oracle، IBM، HP، Rational – که پیش از آن نیاز به یک زبان مدل‌سازی مشترک را احساس کرده بودند، در پاسخ به فراخوان OMG، نسخه UML 1.1 را توسعه دادند و آن را به OMG ارسال نمودند. OMG این پیشنهاد را در سال 1997 پذیرفت و مسئولیت نگهداری مستمر و بازنگری در UML را برعهده گرفت. در سال 2003، OMG نسخه UML 1.5 را عرضه کرد. در سال 2005 نیز با انتشار UML نسخه 2 تغییرات اساسی نسبت به نسخه ابتدایی UML ایجاد گردید و این نسخه پایه‌ی بسیاری از کتاب‌ها، ابزارهای مدل‌سازی شد. پیدایش UML همه چیز را تغییر داد و باعث رشد چشم‌گیر مدل‌سازی تصویری و استفاده گسترده از این زبان شد. UML امروزه نقش یک زبان بین‌المللی را در زمینه‌ی تولید نرم‌افزار بر عهده دارد. موسسه‌ی آماری گارتنر در سال ۲۰۰۶ تعداد متخصصان فناوری اطلاعات که از UML استفاده می‌نمودند را ده میلیون نفر برآورد نمود و همچنین تخمین زده است که در سال ۲۰۰۸ هفتاد درصد شرکت‌های تولید نرم‌افزار در سراسر دنیا از UML استفاده کرده‌اند. در حال حاضر UML بیشترین استفاده را در میان رویه‌های تصویری برای مدل‌سازی سیستم‌های شی‌گرا دارد. این زبان رویه‌های متداول نشان‌گذاری را کاملا به صورت یکپارچه در آورده است. آن‌هایی که طراحی سیستم‌های نرم‌افزاری شی‌گرا را انجام می‌دهند از این زبان (به صورت اشکال هندسی) برای مدل کردن سیستم‌های خود استفاده می‌نمایند. یکی از ویژگی‌های جذاب UML انعطاف‌پذیری آن است. UML توسعه‌پذیر است (یعنی توان بهبود یافتن توسط مشخصه‌های جدید را دارد) و مستقل از هر فرایند تحلیل و طراحی شی‌گرای خاص است. باید توجه داشت که UML تنها یک زبان نمادگذاری و مدل‌سازی است و به عنوان یک متدولوژی توسعه نرم‌افزار استفاده نمی‌شود. اما اکنون تمامی توسعه‌دهندگان می‌توانند طراحی‌های خود را با استفاده از یک مجموعه‌ی استاندارد از نشان‌گذاری‌های تصویری بیان نمایند. UML برای استفاده در فرایندهای طراحی شی‌گرا (OOD) طراحی شده است. تعداد فراوانی از چنین فرایندهایی موجود است، که یکی از بهترین‌های آن Rational Unified Process است که توسط شرکت نرم‌افزاری Rational توسعه داده شده است. RUP یک فرایند غنی برای طراحی برنامه‌های قدرتمند صنعتی محسوب می‌گردد. RUP امکان استفاده مؤثرتری از زبان یکپارچه مدل‌سازی (UML) را فراهم می‌سازد. آخرین نسخه UML چهارده گونه نمودار برای مستندسازی مدل‌های سیستم‌ها فراهم می‌آورد، هر مدل یک خصیصه‌ی مجزا از ساختار یا رفتار یک سیستم را مدل می‌کند. هفت نمودار مربوط به ساختار سیستم و هفت نمودار دیگر در ارتباط با رفتار سیستم می‌باشد. نمودارهای ساختاری (Structure Diagrams)  نمودار کلاس (Class Diagram) رایج‌ترین نموداری است که در UML استفاده می‌شود. این نمودار یک نمای ایستا (static view) از کلاس‌ها را در یک مدل یا بخشی از یک مدل را نشان می‌دهد. در این نمودار صفات و عملیات کلاس را می‌توان به همراه انواع مختلفی از رابطه‌های بین کلاس‌ها نشان داد. نمودار کلاس نمایی شی‌گرا از یک سیستم را نشان می‌دهد. نمودار شی (Object Diagram) نمودارهای شی از نمودارهای کلاس مشتق می‌شوند، بنابراین نمودارهای شی به نمودارهای کلاس وابسته هستند. این نمودار نمونه‌ای از نمودار کلاس را نشان می‌دهد. مفاهیم اساسی برای نمودارهای کلاس و نمودارهای شی مشابه هستند. نمودارهای شی همچنین دید ایستا از یک سیستم را نشان می‌دهند اما این دید ایستا یک تصویر یا نسخه‌ی فوری از سیستم در یک لحظه خاص است. نمودارهای شیء برای ارائه مجموعه‌ای از اشیاء و روابط آن‌ها به عنوان نمونه استفاده می‌شود. نمودار بسته (Package Diagram) ساختار سلسله مراتبی بسته‌های درون سیستم (که گروه‌هایی از کلاس‌ها هستند) در زمان کامپایل و روابطی که میان بسته‌ها وجود دارد را مدل می‌کند. نمودار ساختار مرکب (Composite Structure Diagram) مشابه نمودار کلاس است با این تفاوت که ساختار داخلی یک شی ترکیبی در زمان اجرا را مدل می‌کند و به طراحان سیستم امکان تجزیه‌ی یک شی ترکیبی به قسمت‌های کوچک‌تر را به صورت سلسله مراتبی می‌دهند. نمودار اجزا (Component Diagram) برای نمایش تصویری از سازمان‌دهی، ترتیب و رابطه‌ی میان اجزا و مولفه‌های سیستم به کار می‌رود. این نمودارها برای ایجاد سیستم‌های قابل اجرا نیز مورد استفاده می‌گیرند. به عبارتی این نمودارها چگونگی تقسیم سیستم به مولفه‌های آن و وابستگی بین مولفه‌های سیستم را توصیف می‌کند. نمودارهای اجزا اغلب برای نشان دادن ساختار سیستم‌های یکپارچه پیچیده، مورد استفاده قرار می‌گیرند. نمودار استقرار (Deployment Diagram) نیازمندی‌های فیزیکی (سخت‌افزاری) زمان اجرای سیستم (مثل کامپیوتر یا کامپیوترهایی که سیستم بر روی آن‌ها مستقر خواهد شد)، نیازمندی‌های حافظه، محیط اجرا و سایر ابزارهایی که سیستم در طی اجرا به آن‌ها نیاز دارد را مدل می‌کند. این نمودار ساختاری، معماری سیستم را در زمان استقرار نرم‌افزار نشان می‌دهد. یک نمودار استقرار کارآمد پارامترهای همچون کارایی، مقیاس‌پذیری، قابلیت نگهداری و قابلیت حمل را کنترل می‌کند. نمودار مشخصات (Profile Diagram) به عنوان مکانیزمی برای گسترش UML استفاده می‌شود که به شما امکان می‌دهد که با افزودن بلوک‌های ساختاری جدید، ایجاد ویژگی‌های جدید و تعیین مفاهیم جدید، UML را گسترش داده و سفارشی کنید تا زبان را برای دامنه مسئله‌ی خاص خود شخصی‌سازی کنید.  نمودارهای رفتاری (Behavior Diagrams)  نمودار کاربرد (Use Case Diagram) تعاملات میان یک سیستم و موجودیت‌های خارجی (کنش‌گرها) را بر مبنای مورد استفاده آن‌ها مدل می‌کند. نمودار فعالیت (Activity Diagram) فعالیت یک شی را مدل می‌کند و روند کاری (توالی رویدادها) شی در طی اجرای برنامه را نشان می‌دهد. یک نمودار فعالیت، اعمالی را که شی انجام می‌دهد مدل می‌کند و ترتیب انجام این اعمال را از سوی آن مشخص می‌سازد. نمودار حالت (State Machine Diagram) روش‌هایی را که یک شی از طریق آن‌ها وضعیت را تغییر می‌دهند مدل می‌کند. وضعیت یک شی توسط مقادیر تمامی صفات شی در زمان مورد نظر تعیین می‌گردد. هنگامی که یک شی وضعیت را تغییر می‌دهد، ممکن است آن شی در سیستم به شکلی متفاوت رفتار نماید. نمودارهای تعامل (Interaction Diagrams) زیر مجموعه‌ای از نمودارهای رفتاری هستند که بر گردش کنترل و داده‌ها بین چیزهای مختلف در سیستم مدل‌شده تأکید دارند.  نمودار توالی (Sequence Diagram) تعاملات میان اشیا یک سیستم را مدل می‌کند اما برخلاف نمودارهای ارتباط، آن‌ها بر زمان وقوع تعامل‌ها تاکید دارند. این نمودارها به نشان دادن ترتیب وقوع تعامل‌ها در زمان اجرای یک عملیات کمک می‌نمایند. نمودار ارتباط (Communication Diagram) تعاملات میان اشیا را با تاکید بر کاری که تعامل‌ها انجام می‌دهند، در یک سیستم مدل می‌کند. نمودار زمان‌بندی (Timing Diagram) فشارها و محدودیت‌های زمانی تحمیل‌شده بر تغییرات میدانی و تعاملات اشیا در یک سیستم را مدل می‌کنند. نمودار چشم‌انداز ارتباط (Interaction Overview Diagram) با ترکیب عناصری از انواع متعدد نمودارهای رفتاری (مثل نمودارهای فعالیت و نمودارهای توالی) چشم‌اندازی از جریان کنترل در سیستم را فراهم می‌نماید.   ","date":"Jun 9, 2017","img":"","permalink":"/posts/uml-info/","series":[],"tags":["UML"],"title":"زبان مدل‌سازی یکپارچه (UML) چیست؟"},{"categories":["General","OOP"],"content":"شی‌گرایی یک راه طبیعی تفکر در مورد جهان پیرامون و نوشتن برنامه‌های کامپیوتری است. در دنیای واقعی به هرجا که بنگرید اشیا را مشاهده می‌کنید: اشخاص، حیوانات، گیاهان، اتوموبیل‌ها، هواپیماها، ساختمان‌ها، کامپیوترها و مواردی از این قبیل. انسان‌ها هر روز اشیا را در اطراف خود مشاهده می‌کنند و در مورد آن‌ها به تفکر می‌پردازند.\nاغلب اشیا را به دو دسته تقسیم می‌نماییم: جاندار و بی جان. اشیای جاندار زنده هستند، حرکت می‌کنند و یک سری اعمال انجام می‌دهند. از سوی دیگر، اشیای بی‌جان به خودی خود حرکت نمی‌کنند. اما در هر صورت هر دو نوع شی در یک سری چیزها مشترک هستند. همه‌ی آن‌ها دارای صفاتی می‌باشند (مثلا اندازه، شکل، رنگ و وزن)، و همه‌ی آن‌ها رفتارهایی از خود بروز می‌دهند (مثلا یک توپ قِل می‌خورد، می‌جهد، باد می‌شود و کم باد می‌گردد – یک نوزاد گریه می‌کند، می‌خوابد، می‌خزد، راه می‌رود و چشمان خود را برهم می‌زند – یک اتوموبیل شتاب می‌گیرد، ترمز می‌کند و می‌پیچد). انسان‌ها با مطالعه‌ی صفات اشیا موجود و مشاهده رفتار آن‌ها به کسب اطلاعات در مورد آن‌ها می‌پردازند. اشیای متفاوت می‌توانند دارای صفات مشابه باشند و می‌توانند رفتارهای مشابه از خود بروز دهند. به عنوان مثال، می‌توان میان نوزادان، بزرگسالان و میان انسان‌ها و شامپانزه‌ها شباهت‌هایی یافت. طراحی شی‌گرا (Object-oriented design) اجزای نرم‌افزاری را بر اساس اشیای دنیای واقعی مدل می‌نماید. در حقیقت این روش، مدل‌سازی اشیا توسط صفات، رفتارها و مناسبات مشترک آن‌ها به همان صورتی که ما اشیا دنیای واقعی را توصیف می‌کنیم می‌باشد. طراحی شی‌گرا همچنین ارتباط میان اشیا را مدل می‌کند. دقیقا به همان گونه که افراد به یکدیگر پیغام می‌فرستند (مثلا یک گروه‌بان به یک سرباز دستور می‌دهد)، اشیا نیز از طریق پیغام‌ها با یکدیگر ارتباط برقرار می‌نمایند. مثلا یک شی حساب بانکی ممکن است یک پیغام مبنی بر کاهش پول موجود در خود به یک میزان معین را دریافت نماید. چرا که مشتری آن میزان پول را از حساب خود برداشت نموده است. طراحی شی‌گرا، صفات و اعمال (رفتارها) را در اشیا پنهان (Encapsulate) می‌سازد. اشیا دارای خصوصیت پنهان‌سازی اطلاعات هستند. این بدان معنی است که ممکن است اشیا برقراری ارتباط با دیگری را در میان رابطه‌های خویش تعریف‌شده بدانند، اما آن‌ها اجازه‌ی کسب اطلاع از نحوه پیاده‌سازی سایر اشیا را ندارند. جزییات پیاده‌سازی درون خود اشیا پنهان است. برای نمونه، اگر ما نحوه‌ی استفاده از پدال گاز، پدال ترمز، فرمان و مواردی از این قبیل را بدانیم، می‌توانیم به شکلی کارآمد بدون آن که از جزییات نحوه‌ی عملکرد داخلی سیستم‌های موتور، ترمز و اگزوز آگاهی داشته باشیم، یک اتوموبیل را برانیم. پنهان‌سازی اطلاعات، یک امر حیاتی در مهندسی نرم‌افزار خوب محسوب می‌شود. برنامه‌نویسی با زبان‌هایی که از شی‌گرایی پشتیبانی می‌کنند، برنامه‌نویسی شی‌گرا (Object-oriented programming) نامیده می‌شود. در برنامه‌نویسی شی‌گرا به برنامه‌نویسان امکان پیاده‌سازی یک طراحی شی‌گرا به عنوان یک سیستم نرم‌افزاری کارآمد داده می‌شود. در زبان‌های برنامه‌نویسی شی‌گرا، واحد برنامه‌نویسی کلاس (Class) است که در نهایت اشیا از روی آن نمونه‌سازی (Instantiate) می‌شوند. کلاس‌ها برای اشیا به منزله طرح اولیه برای خانه‌ها است. یک کلاس را می‌توان به عنوان نقشه‌ای برای ساختن یک شی از روی یک کلاس در نظر گرفت. دقیقا همان‌گونه که ما می‌توانیم از روی یک طرح تعداد زیادی خانه بسازیم، می‌توانیم اشیا بسیاری را از روی یک کلاس نمونه‌سازی کنیم. شما نمی‌توانید در طرح یک آشپزخانه اقدام به آشپزی نمایید، بلکه کار آشپزی را در آشپزخانه‌ی موجود در یک خانه انجام می‌دهید. شما نمی‌توانید در طرح یک اتاق خواب بخوابید، بلکه باید در اتاق خواب موجود در یک خانه بخوابید. کلاس‌ها شامل توابعی برای پیاده‌سازی اعمال و داده‌هایی برای پیاده‌سازی صفات می‌باشند. در حقیقت کلاس‌ها دارای مجموعه‌ای از داده‌ها و توابعی هستند که عمل خاصی را بر روی داده‌ها انجام می‌دهند و خدماتی را برای سرویس‌گیرندگان (یعنی سایر کلاس‌ها یا توابعی که از کلاس استفاده می‌نمایند) فراهم می‌نمایند. اجزا داده‌ای یک کلاس تحت عنوان اعضای داده شناخته می‌شوند. برای مثال، یک کلاس حساب بانکی می‌تواند شامل یک شماره حساب و یک موجودی باشد. اجزای تابع یک کلاس تحت عنوان توابع عضو (متد) شناخته می‌شوند. برای مثال، یک کلاس حساب بانکی می‌تواند شامل توابع عضو برای افزایش مبلغ موجودی، کاهش مبلغ موجودی و اعلام موجودی فعلی باشد. کلاس‌ها می‌توانند با سایر کلاس‌ها رابطه داشته باشند. برای مثال، در یک طراحی شی‌گرا از یک بانک، کلاس تحویل‌دار باید با سایر کلاس‌ها مرتبط باشد، کلاس‌هایی از قبیل کلاس \u0026ldquo;مشتری\u0026rdquo;، کلاس \u0026ldquo;حواله‌دهنده\u0026rdquo;، کلاس \u0026ldquo;گاو صندوق\u0026rdquo; و مواردی از این قبیل. این روابط تحت عنوان پیوندها (Associations) شناخته می‌شوند. به عنوان مثالی دیگر در حالتی که اشیا یک کلاس دارای خصیصه‌های یکسان باشند مثل یک کلاس از وسایل نقلیه (اتوموبیل‌ها، کامیون‌ها، واگن‌ها و اسکیت‌ها)، در طراحی شی‌گرا می‌توان از یک کلاس پایه \u0026ldquo;خودرو\u0026rdquo; که شامل ویژگی‌های مشترک بین همه‌ی وسایل نقلیه دارد استفاده نمود. مطمئنا کلاس \u0026ldquo;خودرو\u0026rdquo; ویژگی‌های کلی‌تری از نسبت به هر نوع خاص وسیله نقلیه دارد و همه‌ی وسایل نقلیه می‌توانند از این کلاس به صورت مشترک استفاده نماید یا به اصلاح از آن ارث (Inheritance) ببرند. پیاده‌سازی نرم‌افزار بر اساس کلاس، امکان استفاده‌ی مجدد از کلاس‌ها را در طراحی سیستم‌های نرم‌افزاری بعدی فراهم می‌آورد. مجموعه کلاس‌های مرتبط با هم اغلب به صورت قطعه برنامه‌هایی با قابلیت استفاده مجدد در یک گروه دسته‌بندی می‌شوند. دقیقا همان‌گونه که یک دلال معاملات ملکی می‌گوید سه عامل تاثیر‌گذار بر قیمت املاک \u0026ldquo;مکان، مکان، مکان\u0026rdquo; است، افراد حاضر در جامعه‌ی توسعه‌ی نرم‌افزار هم اغلب می‌گویند سه عامل تاثیر‌گذار بر آینده‌ی توسعه‌ی نرم‌افزار \u0026ldquo;استفاده مجدد، استفاده مجدد، استفاده مجدد\u0026rdquo; است. استفاده مجدد از کلاس‌های موجود در هنگام ساختن کلاس‌ها و برنامه‌های جدید باعث صرفه‌جویی در زمان، هزینه و کار مورد نیاز می‌گردد. همچنین استفاده مجدد به برنامه‌نویسان در جهت ایجاد سیستم‌های قابل اطمینان‌تر و کارآمدتر کمک می‌کند، زیرا کلاس و قطعه برنامه‌های موجود اغلب تست، اشکال‌زدایی و بررسی کارآمدی را به شکلی جامع پشت سر گذاشته اند. با استفاده از فناوری شی، شما می‌توانید بخش اعظم نرم‌افزار جدید مورد نیاز خود را با ترکیب نمودن کلاس‌های موجود بسازید. هر کلاس جدیدی که شما ایجاد می‌نمایید پتانسیل تبدیل شدن به یک سرمایه‌ی نرم‌افزاری با ارزش را دارد، بنابراین شما و سایر برنامه‌نویسان می‌توانید از آن مجددا برای تسریع و بهبود با کیفیت فرایندهای توسعه نرم‌افزار در آینده استفاده کنید.\n","date":"May 12, 2017","img":"","permalink":"/posts/oo-info/","series":[],"tags":["OOP","OOD","Object Oriented","Object"],"title":"شی‌گرایی (Object Oriented) چیست؟"},{"categories":["General"],"content":"چرخه‌ی عمر نرم‌افزار (software life cycle) مراحلی را شامل می‌شود که نرم‌افزار در طی آن‌ها توسعه می‌یابد یعنی از زمانی که ایده آن مطرح می‌شود تا زمانی که استفاده از آن متوقف می‌گردد.\nاین مراحل شامل: تحلیل، طراحی، پیاده‌سازی، تست و اشکال‌زدایی، گسترش، نگهداری و بازنشستگی است. مدل‌های متعددی برای چرخه‌ی عمر نرم‌افزار وجود دارد، که هر کدام اولویت‌ها و ویژگی‌های خود را برای تعیین این موضوع که مهندسان نرم‌افزار چه زمانی و چگونه باید هر یک از این مراحل را انجام دهند دارا می‌باشند. مدل‌های آبشاری (waterfall) این مراحل را یک بار به صورت متوالی انجام می‌دهند، در حالی که مدل‌های تکراری (iterative) ممکن است یک یا چند مرحله را در طی چرخه‌ی عمر یک محصول چندین بار تکرار نمایند. برای تحلیل چرخه‌ی عمر نرم‌افزار باید بر خود مسئله متمرکز شد. در هنگام طراحی یک سیستم، مطمئنا یک نفر باید مسئله را به درستی حل نماید، البته تشخیص مسئله درست هم به همین اندازه مهم است. تحلیل‌گران سیستم، نیازمندی‌هایی را جمع‌آوری که محدوده مسئله مورد نظر را مشخص کند. فرایند جمع‌آوری نیازمندی‌ها یک عمل پایه‌ای در نخستین مرحله از چرخه‌ی عمر نرم‌افزار است. مهندسان نرم‌افزار (اگر بخواهیم دقیق‌تر بگوییم، طراحان سیستم) باید سند نیازمندی‌ها را مورد تحلیل قرار داده و سیستم را قبل از پیاده‌سازی طراحی نمایند. در طی مرحله‌ی تحلیل، طراحان سیستم بر روی درک سند نیازمندی‌ها تمرکز می‌کنند تا الگوی سطح بالایی تولید نمایند که کارهای خواسته‌شده از سیستم را تشریح نماید. خروجی مرحله طراحی – الگوی طراحی – باید نحوه‌ی ساخته‌شدن سیستم را به صورت واضحی مشخص کند تا این نیازمندی‌ها را برآورده سازد.\n","date":"May 10, 2017","img":"","permalink":"/posts/slc-info/","series":[],"tags":["Software","Software Life Cycle","SLC"],"title":"چرخه‌ی عمر نرم‌افزار چیست؟"},{"categories":["General"],"content":"اعداد صحیح برای شمارش مناسب هستند، اما گاهی اوقات ما نیاز داریم که اعداد بسیار بزرگ یا اعدادی با جزء کسری را ذخیره کنیم. اعداد اعشاری یا همان اعداد حقیقی برای ارزش‌گذاری عبارت‌هایی كه نیازمند دقت بیشتری هستند، استفاده می‌شوند. برخلاف اعداد صحیح که به آسانی می‌توان آن‌ها را به مقادیر دودویی (binary) تبدیل کرده و در سیستم‌های کامپیوتری استفاده نمود، برای اعداد اعشاری چالش بزرگی پیش رو است تا علاوه بر تبدیل بهینه‌ی اعداد اعشاری به مقادیر دودویی، دامنه‌ی بزرگی از اعداد را هم شامل شود و همچنین دارای دقت و سرعت پردازش بالایی باشد.\nدر علوم کامپیوتر از اصطلاح ممیز شناور (floating point) به عنوان روشی برای نمایش اعداد اعشاری به طوری که محدوده‌ای وسیع از مقادیر را بپذیرند، استفاده می‌شود. اصطلاح \u0026ldquo;ممیز شناور\u0026rdquo; به این واقعیت اشاره دارد که علامت ممیز اعشار می‌تواند \u0026ldquo;شناور\u0026rdquo; باشد. یعنی می‌تواند تعداد متغیری از ارقام، قبل و بعد از علامت ممیز اعشار داشته باشد. در گذشته کامپیوترها‌ی گوناگون روش‌های متفاوتی در پردازش مقادیر ممیز شناور داشتند که این موضوع باعث می‌شد برنامه‌ها بر روی کامپیوترهای مختلف جواب‌های یکسانی را در خروجی نمایش ندهند. به همین منظور در سال 1985 با تلاش گروهی متشکل از ریاضیدانان، دانشمندان علوم کامپیوتر و شرکت‎های تولید سخت‌افزار به سرپرستی William Kahan از دانشگاه کالیفرنیا، استانداردی برای مقادیر ممیز شناور تحت عنوان IEEE754 به سازندگان سخت‌افزارها عرضه شد. با مطرح شدن استاندارد IEEE754 واگرایی شیوه‌های به کار رفته برای نمایش مقادیر ممیز شناور کاهش یافت و بدین ترتیب برنامه‌های نوشته شده برای مقاصد علمی قابل حمل شدند. بسیاری از کامپیوترهای امروزی برای استفاده از مقادیر ممیز شناور از این استاندارد پیروی می‌کنند. طبق این استاندارد روش نمایش و ذخیره‌سازی متغیرهایی از نوع داده ممیز شناور بسیار شبیه به چگونگی نوشتن اعداد با نماد علمی (scientific notation) می‌باشد. نماد علمی یک روش معمول خلاصه‌نویسی در مورد اعداد خیلی بزرگ یا خیلی کوچک می‌باشد. در نگاه اول شاید نماد علمی کمی پیچیده به نظر برسد، اما اگر فهم درستی از نماد علمی داشته باشید، به شما کمک می‌کند تا درک کنید که نوع داده‌ای ممیز شناور چگونه کار می‌کند، و مهم‌تر از آن دارای چه محدودیت‌هایی می‌باشد. نماد علمی در نماد علمی هر عددی می‌تواند، به صورت حاصل‌ضرب دو عدد به شکل: $$ significand * base^{exponent} $$ نوشته ‌شود که در آن base پایه عددی است و نما یا توان (exponent) یک عدد صحیح مثبت یا منفی، و ضریب علمی (significand) یک عدد حقیقی که در مبنای 10 بزرگ‌تر یا مساوی 1 و کوچک‌تر از 10 است می‌باشد. هر چقدر تعداد ارقام در قسمت بعد از اعشار ضریب علمی بیشتر باشد، عدد شما دقیق‌تر می‌باشد. برای مثال در نماد علمی زیر قسمت 1.2 ضریب علمی می‌باشد و عدد 4 توان می‌باشد. این عدد به عدد 12000 ارزیابی می‌گردد. $$ 1.2 * 10^{4} $$ به عنوان مثال جرم زمین را در نظر بگیرید. اگر بخواهیم جرم زمین را در مبنای دهدهی بنویسیم عددی برابر 5973600000000000000000000 کیلوگرم می‌شود. این یک عدد بسیار بزرگ است. همچنین خواندن آن نیز خیلی سخت است (آیا 19 صفر دارد یا 20 صفر؟). اگر جرم زمین را بخواهیم با نماد علمی بنویسیم، خواهیم داشت: $$ 5.9736 * 10^{24} (kg) $$ همانطور که می‌بینید، خواندن نماد علمی آن بسیار ساده‌تر است. همچنین نماد علمی دارای مزیت دیگری است که طی آن می‌توانیم ساده‌تر دو عدد خیلی بزرگ یا دو عدد خیلی کوچک را با هم مقایسه کنیم. این کار تنها با مقایسه توان دو عدد صورت می‌پذیرد. به طوری کلی می‌توان از قواعد زیر برای تبدیل اعداد به نماد علمی استفاده کنید:\n توان شما از صفر آغاز می شود. ممیز را به سمت چپ ببرید به نحوی که تنها یک رقم غیر از صفر در سمت چپ و قبل از ممیز قرار بگیرد. هر بار که ممیز را یک رقم به سمت چپ منتقل می‌کنید منجر می‌شود تا توان شما 1 واحد افزایش پیدا کند. هر بار که ممیز را یک رقم به سمت راست منتقل می‌کنید منجر می‌شود تا توان شما 1 واحد کاهش پیدا کند. صفرهای قبل از عدد را حذف کنید. صفرهای بعد از عدد را تنها در صورتی حذف کنید که عدد اصلی شما دارای ممیز نباشد. در نماد علمی ترجیح داده می‌شود تا صفرهای بعد از اعشار نگهداری شده و حذف نگردد، چرا که آن صفرها دقت عدد مربوطه را ارائه می‌دهند.\n  برای درک بهتر به مثال‌های زیر توجه کنید: مثال 1 عدد اصلی: 42030 از آخرین رقم در سمت راست شروع کرده و ممیز را 4 رقم به سمت چپ می‌بریم: $$ 4.2030 * 10^{4} $$ هیچ صفری قبل از عدد برای حذف کردن نداریم: $$ 4.2030 * 10^{4} $$ یک صفر در آخرین رقم سمت راست داریم که حذفش می‌کنیم: $$ 4.203 * 10^{4} $$ مثال 2 عدد اصلی: 0.0078900 ممیز را سه رقم به سمت راست می‌بریم تا اولین رقم قبل از ممیز (7) غیر از صفر باشد: $$ 0007.8900 * 10^{3} $$ صفرهای قبل از عدد را از بین می‌بریم: $$ 7.8900 * 10^{3} $$ از آنجا که عدد اصلی ما دارای ممیز می‌باشد، صفرهای سمت راست را حذف نمی‌کنیم: $$ 7.8900 * 10^{3} $$ مثال 3 عدد اصلی: 600.410 ممیز را دو رقم به سمت چپ می‌بریم: $$ 6.00410 * 10^{2} $$ صفر قبل از عدد نداریم که بخواهیم حذفش کنیم: $$ 6.00410 * 10^{2} $$ از آنجا که عدد اصلی ما دارای ممیز می‌باشد، صفرهای سمت راست را حذف نمی‌کنیم: $$ 6.00410 * 10^{2} $$ نماد علمی به صورت دیجیتال یا زمانی که توان به صورت بالانویس مقدور نیست معمولاً با E یا e که معادل «ضربدر ۱۰ به توانِ\u0026hellip;» است نمایش داده می‌شود. به عنوان مثال می‌توان جرم زمین را با نماد علمی به صورت زیر نیز نوشت: $$ 5.9736E24 (kg) $$\nنمایش مقادیر ممیز شناور در IEEE754 استاندارد IEEE754، چند قالب کلی با دقت‌های مختلف از جمله دقت معمولی، دقت مضاعف و دقت‌ مضاعف توسعه‌یافته برای نمایش اعداد ارائه می‌نماید. در این استاندارد، در دقت معمولی از 32 بیت، در دقت مضاعف از 64 بیت و در دقت مضاعف توسعه‌یافته از 128 بیت برای نمایش یک عدد استفاده می‌شود. در روش ارائه‌شده در استاندارد IEEE754 برای نمایش و ذخیره‌سازی انواع ممیز شناور از فرمول زیر استفاده می‌شود: $$ (-1)^{sign} * normalized mantissa * base^{biased exponent} $$ مبنا (base) در نظر گرفته‌شده در استاندارد IEEE754 برابر 2 است. قالب دودویی انواع ممیز شناور نیز به ترتیب زیر است: $$ sign| biased exponent | normalized mantissa $$ علامت (sign) برای اعداد مثبت 0 و برای اعداد منفی 1 می‌باشد و از یک بیت برای نمایش آن استفاده می‌شود. مقدار اعشاری نرمال‌شده (normalized mantissa) بخشی از یک عدد ممیز شناور است که از ارقام معنادار آن تشکیل شده است. بنابراین یک مقدار اعشاری نرمال‌شده عددی است که تنها یک عدد 1 در سمت چپ اعشار دارد. از آنجا همواره عدد سمت اعشار می‌بایست 1 باشد این عدد در فرمت ذخیره‌سازی قرار داده نشده و به صورت پیش‌فرض در نظر گرفته می‌شود. در دقت ساده از 23 بیت، در دقت مضاعف از 52 بیت و در دقت مضاعف توسعه‌یافته از 112 بیت برای نمایش مقدار اعشاری نرمال‌شده استفاده می‌شود. نما یا توان متعادل‌شده (biased exponent) یک عدد صحیح مثبت است که مقدار ثابتی به عنوان bias به آن اضافه شده است تا محدوده توان غیر منفی شود. این مقدار ثابت در دقت معمولی 127، در دقت مضاعف 1023 و در دقت مضاعف توسعه‌یافته 16383 است. همچنین در دقت ساده از 8 بیت، در دقت مضاعف از 11 بیت و در دقت مضاعف توسعه‌یافته از 15 بیت برای نمایش توان متعادل‌شده استفاده می‌شود. به طور مثال ما قصد داریم عدد 5.0- را در به عنوان یک مقدار ممیز شناور معمولی ذخیره کنیم. عدد اصلی در مبنای 2: 0101- برای تبدیل این عدد به یک مقدار اعشاری نرمال‌شده همانند نمایش علمی از آخرین رقم در سمت راست شروع نموده و ممیز را 2 رقم به سمت چپ می‌بریم تا به آخرین 1 برسیم. همچنین به ازای هر رقم یک واحد به توان اضافه می‌کنیم: $$ -01.01 * 10^{2} $$ صفر سمت چپ را نیز حذف می‌کنیم: $$ -1.01 * 10^{2} $$ مقدار ثابت bias را که در دقت معمولی برابر 127 است به توان اضافه می‌کنیم: $$ -1.01 * 10^{2+127} = -1.01 * 10^{129} $$ در عدد به دست آمده مقدار علامت برابر 1، مقدار اعشاری نرمال‌شده برابر 1.01 و توان متعادل‌شده برابر 129 است. از آنجایی که مقدار 1 سمت چپ مقدار اعشاری نرمال‌شده ذخیره نمی‌شود مقدار بیتی عدد -5.0 به صورت زیر است: $$ 0(sign)10000001(exponent)01000000000000000000000(fraction) $$ دقت انواع ممیز شناور از آنجایی که در مقادیر ممیز شناور دقت عدد اعشاری به تعداد بیت قسمت اعشاری محدود شده است در هنگام محاسبات مواردی پیش می‌آید که یک محاسبه مقداری را ایجاد می‌کند که نمی‌تواند دقیقا به وسیله‌ی قالب ممیز شناور ارائه شده توسط IEEE754 نمایش داده شود و سخت‌افزار باید نتیجه را به مقداری که به درستی نمایش داده می‌شود، گرد کند. در استاندارد IEEE754، روش پیش‌فرض برای این کار این است که به نزدیک‌ترین عدد ممکن گرد شود. به عنوان مثال مقدار 1.0 در قالب ممیز شناور به صورت زیر است: $$ 0(sign)01111111(exponent)00000000000000000000000(fraction) $$ که در فرمول IEEE754 به صورت زیر قرار می گیرد: $$ 1.00000000000000000000000(binary) × 2⁰ $$ که برابر عدد زیر در مبنای 2 است: $$ 1.00000000000000000000000 $$ کوچک ترین عددی که می توان به این عدد اضافه یا از این عدد کم کرد برابر با مقدار زیر است: $$ 0.00000000000000000000001(binary) = 0.00000011920928955078(decimal) $$ اگر عددی کوچکتر از 0.00000011920928955078 را جمع یا تفریق کنید، نتیجه تغییر نخواهد کرد زیرا نتیجه به مقدار قبلی گرد می‌شود. وقتی از عدد شناور معمولی استفاده می‌کنید این دقتی است که با عدد 1.0 دارید. در واقع در این مورد مشکل بزرگی نیست زیرا 0.00000011920928955078 برای اکثر برنامه‌ها به اندازه کافی کوچک است. به عنوان مثالی دیگر مقدار 1000000.0 در قالب ممیز شناور به صورت زیر است: $$ 0(sign)10010010(exponent)11101000010010000000000(fraction) $$ که در فرمول IEEE754 به صورت زیر قرار می‌گیرد: $$ 1.11101000010010000000000(binary) × 2¹⁹ $$ که برابر عدد 11110100001001000000.0000 در مبنای 2 است: $$ 11110100001001000000.0000 $$ کوچک‌ترین عددی که می‌توان به این عدد اضافه یا از این عدد کم کرد برابر با مقدار زیر است: $$ 0.0001(binary) = 0.0625(decimal) $$ در این مورد، دقت در مقایسه با زمانی که عدد 1.0 است بسیار کمتر است که این می‌تواند مشکل‌ساز باشد. به عنوان مثال اگر از نوع ممیز شناور با دقت معمولی برای نمایش زمان (ثانیه) از زمان شروع یک برنامه کاربردی استفاده شده باشد و برنامه هر 0.05 ثانیه زمان را شمارش کند، پس از 1000000.0 (یا قبل از آن)، زمان از حرکت باز می‌ایستد!\n","date":"Feb 8, 2017","img":"","permalink":"/posts/float-info/","series":[],"tags":["Float","Floating-point","Scientific Notation","IEEE754"],"title":"ممیز شناور (Floating Point) چیست؟"},{"categories":["General"],"content":"UUID اختصار عبارت Universally Unique Identifier به معنای شناسه منحصر به فرد جهانی می‌باشد. به‌جای این اصطلاح از GUID که اختصار عبارت Globally Unique Identifier به معنای شناسه منحصر به فرد عمومی نیز استفاده می‌شود. GUID یک اصطلاح صنعتی است که توسط شرکت مایکروسافت برای ارائه یک شماره مرجع که در هر زمینه‌ای منحصر به فرد است، تعریف شده است در حالی که در محیط آکادمیک و در استانداردها از اصطلاح UUID استفاده شده است. هر دو اصطلاح به یک موضوع اشاره دارند و تفاوتی در استفاده ندارند.\nUUIDها یک عدد صحیح 128 بیتی هستند که اگر طبق روش‌های استاندارد تولید شوند، بدون آنکه به یک نهاد ثبت‌کننده مرکزی یا هماهنگی با سایر تولیدکننده‌های UUID برای تایید یکتایی نیاز داشته باشند، عملا یکتا خواهند بود. اگرچه احتمال اینکه یک UUID تکراری باشد، صفر نیست، اما آنقدر به صفر نزدیک است که می‌توان از آن چشم‌پوشی نمود. بنابراین هر کسی می‌تواند یک UUID ایجاد کند و از آن برای شناسایی موجودیتی استفاده کند و اطمینان داشته باشد که شناسه‌ای که تولید کرده ‌است با شناسه‌هایی که قبلا تولید شده یا بعدا تولید خواهد شد، تداخلی ندارد. اطلاعاتی که بوسیله UUIDها توسط موجودیت‌های مستقل برچسب‌گذاری شده‌اند می‌توانند بعدا با یکدیگر ادغام شده و در یک بانک اطلاعاتی قرار گیرند، بدون آنکه نیاز به از بردن تداخل‌های بین شناسه‌ها شود. UUIDها توسط Open Software Foundation (OSF) که بخشی از Distributed Computing Environment (DCE) است استانداردسازی شده‌اند. UUIDها در سال 1996 به عنوان بخشی از استاندارد ISO/IEC 11578:1996 \u0026ldquo;Information technology – Open Systems Interconnection – Remote Procedure Call (RPC)” و همچنین در سال 2005 نیز در استاندارد ITU-T Rec. X.667 | ISO/IEC 9834-8:2005 مستندسازی شده‌اند. همچنین Internet Engineering Task Force (IETF) با انتشار Standards-Track RFC 4122 که از نظر فنی با استاندارد ITU-T Rec. X.667 | ISO/IEC 9834-8 برابر است مستندات مربوط به UUIDها منتشر کرده است. در شیوه متعارف نمایش متنی، شانزده بایت یک شناسه GUID توسط 32 رقم هگزادسیمال (مبنای 16) که در 5 گروه که توسط خط فاصله از یکدیگر جدا شده‌اند در قالب 12-4-4-4-8 که در مجموع 36 کاراکتر (32 کاراکتر الفبایی و چهار خط فاصله) را تشکیل می‌دهد، نشان داده می‌شوند.\n1xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx نمونه 1\n1123E4567-E89B-12D3-A456-426614174000 نمونه 2\n1B4D0257C-BE19-4800-BA11-A09AC2561898 UUIDها دارای سه نوع و پنج نسخه می‌باشند. چهار بیت از رقمی که با M نشان داده شده ‌است، نسخه UUID و رقمی که با N نشان داده شده ‌است، نوع UUID را مشخص می‌کند.\n1xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx در نمونه 1، مقدار M برابر یک و مقدار N برابر a است، به این معنی است که نوع UUID از نوع یک، و نسخه آن نیز ۱ می‌باشد. در نمونه 2، مقدار M برابر 4 و مقدار N برابر b است، به این معنی که نوع UUID از نوع یک و نسخه آن 4 می‌باشد.\nانواع UUID نوع صفر - N = 0..7 برای سازگاری با سیستم قدیمی قالب UUID 1.5 سامانه محاسبات شبکه‌ایApollo در سال 1988 تعریف شده ‌است. در این قالب، 6 بایت اول زمان با طول 48 بیت است (تعداد واحدهای 4 میلی ثانیه از 1 ژانویه 1980 UTC). دو بایت بعدی رزرو شده است و بایت بعدی نوع آدرس‌دهی در شبکه Apollo است. هفت بایت آخر نیز یک شناسه میزبان 56 بیتی است که با توجه به نوع آدرس‌دهی تعیین می‌شود.\nنوع یک - N = 8..b این نوع در استاندارد RFC 4122/DCE 1.1 UUIDs ارجاع داده شده است و نوع رایج UUID می‌باشد.\nنوع دو - N = c..d این نوع که با عنوان GUID توسط شرکت مایکروسافت مطرح شده است اولین بار توسط این شرکت در سیستم عامل ویندوز مورد استفاده قرار گرفته است. نوع یک و دو در نمایش رشته‌ای مشابه هم هستند و تنها در بیت مربوط به نوع باهم متفاوت هستند اما در نمایش دودویی در روش نگهداری نیز باهم متفاوت هستند. در نوع یک از ترتیب بایت big-endian استفاده می‌شود در حالی که در نوع دو از ترتیب بایت little-endian استفاده شده است.\nنوع رزرو شده - N = e..f این بازه برای استفاده در آینده رزرو شده است.\nنسخه های UUID نسخه یک – زمان و آدرس MAC در این نسخه از زمان سیستم و آدرس MAC کارت شبکه که منحصر به فرد برای تولید UUID استفاده می‌شود. با داشتن UUID نسخه 1 با استخراج مقدار timestamp می‌توانید به این موضوع پی ببرید که این UUID چه زمانی تولید شده است. قالب متعارف UUIDهای مبتنی بر زمان به صورت زیر است:\n   نام اندازه (بایت) طول (هگزادسیمال) محتوا     time_low 4 8 عدد صحیحی که ۳۲ بیت پایینی زمان است   time_mid 2 4 عدد صحیحی که ۱۶ بیت میانی زمان است   time_hi_and_version 2 4 ۴ بیت پرارزش، نسخه را مشخص کرده و ۱۲ بیت دیگر ۱۲ بیت بالایی زمان است   clock_seq_hi_and_res clock_seq_low 2 4 بیت‌های ۱ تا ۳ پرارزش نوع UUID و۱۳ تا ۱۵ بیت باقی مانده توالی ساعت است (clock sequence)   node 6 12 شناسه گره ۴۸ بیتی    نسخه دو - زمان و آدرس MAC و نسخه امنیتی DCE این نسخه به صورت خاص در استاندارد RFC 4122 تعریف نشده است و عمومیت ندارد. مشابه نسخه 1 است با این تفاوت که 4 بایت ابتدایی از timestamp با POSIX UID کاربر و بایت پر ‌ارزش توالی ساعت با POSIX UID دامنه جایگزین شده است.\nنسخه سه – MD5 hash و Namespace در این نسخه برای تولید UUID از Hash نمودن نام و شناسه Namespace توسط الگوریتم MD5 استفاده می‌شود. شناسه فضای نام می‌بایست خود منحصر به فرد باشد. مانند آدرس‌ها، نام‌های دامنه، شناسه موجودیت‌ها و نام‌های متمایز X.500 می‌توانند به عنوان فضای نام انتخاب شوند.\nنسخه چهار – تصادفی در این نسخه از اعداد تصادفی برای تولید UUID استفاده می‌شود. از 128 بیت، 6 بیت برای نوع و نسخه UUID رزرو شده و مابقی 122 بیت به صورت تصادفی مقدار می‌گیرند که 2 به توان 122 احتمال را شامل می‌شود. از روش های متفاوتی برای تولید اعداد تصادفی در این نسخه استفاده می‌شود و استاندارد مشخصی در این زمینه وجود ندارد.\nنسخه پنج - SHA-1 hash و Namespace مشابه نسخه 3 است با این تفاوت که از الگوریتم SHA-1 به جای MD5 برای Hash نمودن استفاده می‌شود.\nUUID خالی یا Nil UUID برای UUID یک مقدار خالی یا تهی در نظر گرفته شده است که مقدار آن 00000000-0000-0000-0000-000000000000 می‌باشد.\nصحت یکتایی UUID برخورد (Collisions) هنگامی رخ می‌دهد که یک UUID بیش از یک بار ایجاد شده و به مراجع مختلف اختصاص داده شود. در مورد UUIDهای نسخه 1 و نسخه 2 که با استفاده از آدرس‌های MAC کارت‌های شبکه که منحصر به فرد هستند ساخته شده‌اند، فقط زمانی که پیاده‌سازی استانداردها متفاوت باشد یا ایراداتی در آن وجود داشته باشد احتمال برخورد وجود دارد.\nبرخلاف نسخه 1 و نسخه 2 UUID که از آدرس‌های MAC منحصر به فرد کارت‌های شبکه استفاده می‌کنند، در نسخه 1 و 2 UUID تصادفی و نسخه 3 و 5 که مبتنی بر Hash هستند و نسخه 4 UUID تصادفی، احتمال برخورد وجود دارد. البته با احتمال بسیار کمی که به طور معمول قابل چشم پوشی است. این احتمال را می‌توان دقیقا بر اساس تجزیه و تحلیل پارادوکس تولد محاسبه کرد.\nبه عنوان مثال، تعداد UUIDهای نسخه 4 تصادفی که باید ایجاد شوند تا به احتمال 50٪ حداقل یک برخورد باید تولید شود برابر 2.71 کوئین تیلیون است. این عدد معادل تولید 1 میلیارد UUID در ثانیه برای حدود 85 سال است. فایلی که حاوی این تعداد UUID باشد، با 16 بایت در هر UUID، تقریباً 45 اگزا بایت خواهد بود. احتمال یافتن نسخه تکراری در نسخه 103 تریلیون نسخه 4 UUID یک در میلیارد است.\n","date":"Feb 5, 2017","img":"","permalink":"/posts/uuid-guid-info/","series":[],"tags":["UUID","GUID"],"title":"UUID چیست؟"},{"categories":["General"],"content":"IP اختصار عبارت Internet Protocol است که مدل فنی ارسال و دریافت بسته‌ها در اینترنت را به همراه آدرس فرستنده و گیرنده در شبکه‌ی اینترنت یا هر شبکه‌ی کامپیوتری مشخص می‌کند. در حال حاضر دو نسخه برای IP وجود دارد که شامل IPv4 و IPv6 است.\nIPv6 که Internet Protocol Next Generation نیز خوانده می‌شود، جدیدترین پروتکل اینترنت برای اختصاص آدرس IP است که برای تکمیل و در نهایت جایگزین شدن IPV4 در نظر گرفته شده است. در حال حاضر تا زمان مقتضی شاهد استفاده از هر دو پروتکل به‌صورت هم‌زمان خواهیم بود تا اینکه در نهایت IPv6 به‌صورت کامل جای این پروتکل را بگیرد. IPv6 به این علت طراحی شده است تا علاوه بر داشتن آدرس‌های بیشتر برای اتصال دستگاه‌های بیشتر در مقایسه با IPv4، ظرفیت انتقال اطلاعات در شبکه اینترنت یا همان ترافیک را افزایش دهد. IPv4 یک آدرس اینترنتی 32 بیتی است که به‌صورت اعداد ده‌دهی (دستگاه اعداد مبنای ۱0) در قالب یک رشته نمایش داده می‌شود. یک آدرس اینترنتی مبتنی بر IPv4 به‌صورت چهار دسته (Octet) 8 بیتی نوشته می‌شود که توسط یک نقطه از هم جدا می‌شوند. هر یک از چهار دسته عدد سه‌تایی می‌تواند مقادیر صفر تا 255 را داشته باشد. پس برای هر بخش می توان 256 رقم (2 به توان 8) را در نظر گرفت که با این حساب 2 به توان 32 یا 4294967296 رقم خواهیم داشت. برای مثال آدرس زیر یک آدرس اینترنتی مبتنی بر IPv4 است.\n1172.16.110.1 IPv6 یک آدرس اینترنتی 128 بیتی است که به‌صورت اعداد هگزادسیمال استاندارد (دستگاه اعداد مبنای 16) در قالب یک رشته نمایش داده می‌شود. یک آدرس اینترنتی مبتنی بر IPv6 به‌صورت هشت دسته (Octet) 16 بیتی نوشته می‌شود که توسط یک کالِن از هم جدا می‌شوند. هر یک از هشت دسته 8 بیتی می‌تواند مقادیر 0000 تا FFFF را داشته باشد. پس برای هر بخش می‌توان 65,536 رقم (2 به توان 16) را در نظر گرفت که با این حساب 2 به توان 128 یا 340,282,366,920,938,463,463,374,607,431,768,211,456 عدد خواهیم داشت که حدود 7,922,816,251,426,433,759,354 برابر بیشتر از IPv4 می‌باشد. برای مثال آدرس زیر یک آدرس اینترنتی مبتنی بر IPv6 است.\n165b3:b834:45a3:0000:0000:762e:0270:5224 در IPv6 بخش‌هایی که تمام رقم‌های آن صفر می‌باشند را می‌توان حذف نمود و به جای آن‌ها از کاراکتر : استفاده کرد. به عنوان مثال آدرس‌های زیر مشابه هم هستند:\n12001:cdba:0000:0000:0000:0000:3257:9652 232001:cdba:0:0:0:0:3257:9652 452001:cdba::3257:9652 ","date":"Jan 3, 2017","img":"","permalink":"/posts/ip-info/","series":[],"tags":["IP"],"title":"آدرس IP چیست؟"},{"categories":["General"],"content":"به منظور استفاده از جداول نمونه یکسان در مطالب این وبلاگ تصمیم گرفتم در یک مطلب جداگانه اسکریپت‌های مربوط به ایجاد جداول و ثبت داده‌های پیش فرض آن را برای هر نوع بانک اطلاعاتی قرار دهم. در این مطلب اسکریپت مربوط به بانک اطلاعاتی Oracle قرار داده شده است.\nجدول regions 1CREATETABLEregions(2region_idNUMBER(10)PRIMARYKEY,3region_nameVARCHAR2(25)DEFAULTNULL4);56INSERTINTOregions(region_id,region_name)VALUES(1,\u0026#39;Europe\u0026#39;);7INSERTINTOregions(region_id,region_name)VALUES(2,\u0026#39;Americas\u0026#39;);8INSERTINTOregions(region_id,region_name)VALUES(3,\u0026#39;Asia\u0026#39;);9INSERTINTOregions(region_id,region_name)VALUES(4,\u0026#39;Middle East and Africa\u0026#39;);جدول countries 1CREATETABLEcountries(2country_idCHAR(2)PRIMARYKEY,3country_nameVARCHAR2(40)DEFAULTNULL,4region_idNUMBER(10)NOTNULL,5FOREIGNKEY(region_id)REFERENCESregions(region_id)ONDELETECASCADE6);78INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;AU\u0026#39;,\u0026#39;Australia\u0026#39;,3);9INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;AR\u0026#39;,\u0026#39;Argentina\u0026#39;,2);10INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;BE\u0026#39;,\u0026#39;Belgium\u0026#39;,1);11INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;BR\u0026#39;,\u0026#39;Brazil\u0026#39;,2);12INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;CA\u0026#39;,\u0026#39;Canada\u0026#39;,2);13INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;CH\u0026#39;,\u0026#39;Switzerland\u0026#39;,1);14INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;CN\u0026#39;,\u0026#39;China\u0026#39;,3);15INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;DE\u0026#39;,\u0026#39;Germany\u0026#39;,1);16INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;DK\u0026#39;,\u0026#39;Denmark\u0026#39;,1);17INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;EG\u0026#39;,\u0026#39;Egypt\u0026#39;,4);18INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;FR\u0026#39;,\u0026#39;France\u0026#39;,1);19INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;HK\u0026#39;,\u0026#39;HongKong\u0026#39;,3);20INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;IL\u0026#39;,\u0026#39;Israel\u0026#39;,4);21INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;IN\u0026#39;,\u0026#39;India\u0026#39;,3);22INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;IT\u0026#39;,\u0026#39;Italy\u0026#39;,1);23INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;JP\u0026#39;,\u0026#39;Japan\u0026#39;,3);24INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;KW\u0026#39;,\u0026#39;Kuwait\u0026#39;,4);25INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;MX\u0026#39;,\u0026#39;Mexico\u0026#39;,2);26INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;NG\u0026#39;,\u0026#39;Nigeria\u0026#39;,4);27INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;NL\u0026#39;,\u0026#39;Netherlands\u0026#39;,1);28INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;SG\u0026#39;,\u0026#39;Singapore\u0026#39;,3);29INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;UK\u0026#39;,\u0026#39;United Kingdom\u0026#39;,1);30INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;US\u0026#39;,\u0026#39;United States of America\u0026#39;,2);31INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;ZM\u0026#39;,\u0026#39;Zambia\u0026#39;,4);32INSERTINTOcountries(country_id,country_name,region_id)VALUES(\u0026#39;ZW\u0026#39;,\u0026#39;Zimbabwe\u0026#39;,4);","date":"Jan 8, 2014","img":"","permalink":"/posts/oracle-sample-tables/","series":[],"tags":["Oracle"],"title":"نمونه جدول‌های Oracle"},{"categories":["General"],"content":"در این مطلب کتاب‌های معتبر مرتبط با برنامه‌نویسی و بانک‌های اطلاعاتی را برای دانلود قرار دادم. این مطلب به مرور به‌روزرسانی می‌شود و کتاب‌های بیشتری به آن اضافه می‌شود.\n Java How to Program, 11/e, Early Objects by Paul Deitel, Harvey Deitel Pearson  Head First Java, A Brain-Friendly Guide, 3rd Edition by Kathy Sierra, Bert Bates, Trisha Gee - O\u0026rsquo;Reilly Media  ","date":"Jan 6, 2014","img":"","permalink":"/posts/books/","series":[],"tags":[],"title":"کتابخانه"},{"categories":["General"],"content":"به منظور ترجمه یکسان کلمات انگلیسی در مطالب این وبلاگ تصمیم گرفتم در یک مطلب جداگانه ترجمه کلمات (یا معادل فارسی مورد استفاده) را قرار دهم.\nassembly - اسمبلی  checklist - چک لیست  class - کلاس  clause - عبارت  code - کد  comma - کاما  database - بانک اطلاعاتی  namespace - فضای نام  object - شی  query - پرس‌و‌جو\n","date":"Jan 5, 2014","img":"","permalink":"/posts/dict/","series":[],"tags":[],"title":"واژه نامه"},{"categories":null,"content":"","date":"Jan 1, 0001","img":"","permalink":"/contact/","series":null,"tags":null,"title":"تماس با من"}]