[{"categories":["شتاب"],"content":"سامانه‌ی شتاب به عنوان تنها سوئیچ ملی بین بانکی کشور، سیستمی مبتنی بر کارت‌ بوده و وظیفه تبادل تراکنش‌های بین بانکی و اعمال مقررات بانک مرکزی به عنوان مقام ناظر را بر عهده دارد و سطح گستردگی این سامانه شامل کلیه بانک‌های کشور است که با اتصال به چند سوئیچ برون‌مرزی، کل تراکنش‌های کارتی کشور را پوشش می‌دهد. سامانه‌ی شتاب جهت تبادل پیام‌ها و تراکنش‌های مالی از استاندارد ISO8583 استفاده کرده و قابلیت پشتیبانی از سه ویرایش این استاندارد که در سال‌های 1987، 1993 و 2003 ارائه گردیده است را دارد. بانک مرکزی در سال 1392 با ارائه نسخه 7 شتاب بانک‌ها را ملزم به استفاده از ویرایش 2003 این استاندارد کرده است. شتاب وظیفه انتقال امن اطلاعات و داده‌های مربوط به تراکنش‌های ‌مالی و غیرمالی به بانک‌های صادرکننده و یا پذیرنده را دارد. این مرکز با استفاده از سخت افزارها، نرم افزارها و شبکه‌ی ارتباطی خود، پیام‌ها و داده‌های اخذ شده از اعضا را پذیرش کرده، آن‌ها را ثبت، مسیریابی و به بانک‌های صادرکننده یا پذیرنده ارسال می‌نماید. نتیجه این اقدامات دریافت خدمات مبتنی بر کارت توسط دارندگان کارت بانک‌ها از تجهیزات سایر بانک‌ها می‌باشد. شتاب برای نظارت بیشتر بر شبکه‌ی بانکی با ارتباط با مرکز کنترل و نظارت اعتباری (مکنا) کلیه سوابق مشتریان و قوانین بالا دستی را کنترل و بر تراکنش‌های تبادلی در این شبکه نظارت دارد.\n","date":"Jun 3, 2020","img":"","permalink":"/posts/shetab-info/","series":[],"tags":["شتاب","Shetab"],"title":"سامانه شتاب"},{"categories":["DotNet","CSharp","SQLServer"],"content":"SQL Server به منظور ارتقا در مدل برنامه‌نویسی پایگاه داده خود از نسخه 2005 تکنولوژی SQL CLR را معرفی نمود. این تکنولوژی همچنین با اسامی CLR Integrated ،CLR Enabled و CLR Embedded نیز شناخته می‌شود. هدف آن این است که شما بتوانید اشیاء پایگاه داده‌ای از قبیل Stored Procedure ،Function ،Trigger را با استفاده از CSharp و یا VB ایجاد کرده و آن را در SQL Server مورد استفاده قرار دهید. تکنولوژی SQL CLR با میزبانی کردن از (dotNET Common Language Runtime) یا همان محیط زمان اجرای dotNET در SQL Server، به مدیران پایگاه داده اجازه می‌دهد تا از قابلیت‌های موجود در dotNET برای تعریف اشیاء پایگاه داده استفاده کنند. این قابلیت توسط فضاهای نام System.Data ،System.Data.Sql و Microsoft.SqlServer.Server که در اسمبلی System.Data.dll در dotNET قرار داده شده‌اند، پشتیبانی می‌گردند. ایجاد اشیاء پایگاه داده با استفاده از امکان SQL CLR، طی مراحل زیر ممکن می‌گردند:\n پیاده‌سازی کدها در CSharp یا VB در dotNET و Compile آن بارگذاری و اجرای کد Compile شده در مرحله قبل در SQL Server  فعال سازی امکان SQL CLR در پایگاه داده ایجاد اسمبلی از کد مزبور در پایگاه داده ایجاد شی پایگاه داده‌ای از اسمبلی مرحله قبل     پیاده‌سازی کدها در CSharp یا VB در dotNET و Compile آن به عنوان مثال کد مورد نظر خود را در کلاسی با نام StoredProcedures و در تابع SP1 نوشته و آن را Compile می‌کنیم. کد Compile شده را (StoredProcedures.dll) باید در مرحله بعد در SQL Server بارگذاری کنیم. البته کد زیر یک مثال hello world بوده و تنها به منظور آشنایی با نحوه انجام کار می باشد. از تمامی قابلیت‌ها و کلاس‌های موجود در dotNET می توان در این کلاس استفاده نمود.\n1using System; 2using System.Data; 3using Microsoft.SqlServer.Server; 4using System.Data.SqlTypes; 56public class StoredProcedures 7{ 8[Microsoft.SqlServer.Server.SqlProcedure] 9public static void SP1() 10{ 11SqlContext.Pipe.Send(\u0026#34;Hello world!\\n\u0026#34;); 12} 13} فعال‌سازی امکان CLR SQL در پایگاه داده امکان CLR SQL در SQL Server به صورت پیش فرض غیرفعال است و برای فعال‌سازی آن باید کد زیر را اجرا کرد:\n1sp_configure\u0026#39;show advanced options\u0026#39;,12RECONFIGURE3GO45sp_configure\u0026#39;clr enabled\u0026#39;,16RECONFIGURE7GO89sp_configure\u0026#39;show advanced options\u0026#39;,010RECONFIGURE11GOبرای غیرفعال‌سازی هم کد زیر را باید اجرا نمود:\n1sp_configure\u0026#39;show advanced options\u0026#39;,12RECONFIGURE3GO45sp_configure\u0026#39;clr enabled\u0026#39;,06RECONFIGURE7GO89sp_configure\u0026#39;show advanced options\u0026#39;,010RECONFIGURE11GOبرای اینکه فعال یا غیرفعال بودن SQL CLR را در SQL SERVER بررسی نماییم باید کد زیر را اجرا نمود:\n1SELECTname2,CAST(valueASint)ASvalue_configured3,CAST(value_in_useASint)ASvalue_in_use4FROMsys.configurations5WHEREname=\u0026#39;clr enabled\u0026#39;ایجاد اسمبلی در پایگاه داده گام بعدی ایجاد اسمبلی در پایگاه داده از روی کد Compile شده است.\n1CREATEASSEMBLYQClrIntegration2FROM\u0026#39;H:\\Clr\\StoredProcedures.dll\u0026#39;3WITHPermission_set=safe4GOبا توجه به کدی که نوشته‌ایم و برای کنترل دسترسی کد CLR به دیگر کدها از PERMISSION_SET استفاده می‌گردد:\n ویژگی SAFE به اسمبلی ها اجازه می‌دهد که تنها محاسبات محلی و دسترسی به فایل‌های محلی را داشته باشد. ویژگی EXTERNAL_ACCESS مشابه ویژگی قبلی با این تفاوت که اسمبلی می‌تواند به منابع شبکه دسترسی داشته باشد. ویژگی UNSAFE اجازه دسترسی نامحدود به منابع و کدهای غیر از dotNet و مدیریت نشده (Unmanaged Code) را هم می‌دهد.  برای استفاده از ویژگی UNSAFE باید ویژگی اعتماد (trustworthy) را در پایگاه داده فعال کرد. این ویژگی مشخص می‌کند که پایگاه داده به کدهای بیرونی اعتماد دارد (البته توصیه نمی‌شود). در غیر این صورت با فعال‌سازی خصوصیت UNSAFE خطا اعلام می‌شود.\n1ALTERDATABASEDB_NAME2SETtrustworthyON3GOبه طور کلی فعال کردن استفاده از SQL CLR سطح حملات به SQL Server را وسیع‌تر می‌کند و آن را از نظر اسمبلی‌های غیر عمدی و مخرب در معرض خطر قرار می‌دهد. با توجه به ضرورت استفاده از SQL CLR بسیاری از چک لیست‌های امنیتی فقط اسمبلی‌های ایجاد شده با دسترسی SAFE را مجاز می‌دانند و اسمبلی‌های ایجاد شده با دسترسی‌های UNSAFE و EXTERNAL_ACCESS را خطرناک می‌شمارند.\nایجاد شی پایگاه داده ای از اسمبلی مرحله قبل حال می‌توان از اسمبلی ایجاد شده در مرحله قبل برای ایجاد Stored Procedure و یا Function مورد نظر استفاده نمود. چون در مرحله قبل ما کلاسی از نوع Stored Procedure ایجاد کردیم، در SQL Server نیز برای استفاده از آن یک Stored Procedure ایجاد می‌کنیم.\n1CREATEPROCEDUREhello2AS3EXTERNALNAMEhelloworld.StoredProcedures.SP14GOبا اجرای Stored Procedure، کد نوشته شده در تابع sp1 اجرا می‌گردد:\n1EXEChello23-- Hello world! برای حذف ابتدا باید شی‌هایی که ارجاعی از اسمبلی حذف و سپس خود اسمبلی حذف گردد:\n1DROPPROCEDUREhello2GO34DROPASSEMBLYhelloworld5GO","date":"Feb 7, 2020","img":"","permalink":"/posts/sql-server-clr/","series":[],"tags":["SQLServer","CLR","CSharp","DotNet","SQL CLR","CLR Integrated","CLR Embedded"],"title":"استفاده از CLR در SQL Server"},{"categories":["DotNet","CSharp"],"content":"برای ایجاد و استفاده از UUID در زبان برنامه‌نویسی CSharp از ساختار Guid موجود در کتابخانه System استفاده می‌شود:\n1public static Guid NewGuid() 2{ 3return Guid.NewGuid(); 4} guid ایجاد شده در این روش از نوع و نسخه چهارم UUID است و به صورت تصادفی تولید می‌شود. برای تولید guid به صورت ترتیبی می‌توان از کد زیر استفاده نمود:\n1public static Guid NewSequentialGuid() 2{ 3var uid = Guid.NewGuid().ToByteArray(); 4var binDate = BitConverter.GetBytes(DateTime.UtcNow.Ticks); 56var secuentialGuid = new byte[uid.Length]; 78secuentialGuid[0] = uid[0]; 9secuentialGuid[1] = uid[1]; 10secuentialGuid[2] = uid[2]; 11secuentialGuid[3] = uid[3]; 12secuentialGuid[4] = uid[4]; 13secuentialGuid[5] = uid[5]; 14secuentialGuid[6] = uid[6]; 1516// set the first part of the 8th byte to \u0026#39;1100\u0026#39; so  17// later we\u0026#39;ll be able to validate it was generated by us  1819secuentialGuid[7] = (byte)(0xc0 | (0xf \u0026amp; uid[7])); 2021// the last 8 bytes are sequential,  22// it minimizes index fragmentation  23// to a degree as long as there are not a large  24// number of Secuential-Guids generated per millisecond  2526secuentialGuid[9] = binDate[0]; 27secuentialGuid[8] = binDate[1]; 28secuentialGuid[15] = binDate[2]; 29secuentialGuid[14] = binDate[3]; 30secuentialGuid[13] = binDate[4]; 31secuentialGuid[12] = binDate[5]; 32secuentialGuid[11] = binDate[6]; 33secuentialGuid[10] = binDate[7]; 3435return new Guid(secuentialGuid); 36} برای بررسی رشته‌ای که حاوی guid است به ساختار guid می‌توان از کد زیر استفاده نمود:\n1public static bool IsGuid(string guidString) 2{ 3return Guid.TryParse(guidString, out _); 4} برای بررسی اینکه آیا مقدار guid مورد نظرتان یک guid خالی است یا خیر می‌توان از کد زیر استفاده نمود:\n1public static bool IsEmptyGuid(Guid guid) 2{ 3return guid == Guid.Empty; 4} ","date":"Feb 6, 2020","img":"","permalink":"/posts/guid-csharp/","series":[],"tags":["UUID","GUID","CSharp","DotNet"],"title":"کار با GUID در CSharp"},{"categories":["General"],"content":"UUID اختصار عبارت Universally Unique Identifier به معنای شناسه منحصر به فرد جهانی می‌باشد. به‌جای این اصطلاح از GUID که اختصار عبارت Globally Unique Identifier به معنای شناسه منحصر به فرد عمومی نیز استفاده می‌شود. GUID یک اصطلاح صنعتی است که توسط شرکت مایکروسافت برای ارائه یک شماره مرجع که در هر زمینه‌ای منحصر به فرد است، تعریف شده است در حالی که در محیط آکادمیک و در استانداردها از اصطلاح UUID استفاده شده است. هر دو اصطلاح به یک موضوع اشاره دارند و تفاوتی در استفاده ندارند. UUIDها یک عدد صحیح 128 بیتی هستند که اگر طبق روش‌های استاندارد تولید شوند، بدون آنکه به یک نهاد ثبت‌کننده مرکزی یا هماهنگی با سایر تولیدکننده‌های UUID برای تایید یکتایی نیاز داشته باشند، عملا یکتا خواهند بود. اگرچه احتمال اینکه یک UUID تکراری باشد، صفر نیست، اما آنقدر به صفر نزدیک است که می‌توان از آن چشم‌پوشی نمود. بنابراین هر کسی می‌تواند یک UUID ایجاد کند و از آن برای شناسایی موجودیتی استفاده کند و اطمینان داشته باشد که شناسه‌ای که تولید کرده ‌است با شناسه‌هایی که قبلا تولید شده یا بعدا تولید خواهد شد، تداخلی ندارد. اطلاعاتی که بوسیله UUIDها توسط موجودیت‌های مستقل برچسب‌گذاری شده‌اند می‌توانند بعدا با یکدیگر ادغام شده و در یک پایگاه داده قرار گیرند، بدون آنکه نیاز به از بردن تداخل‌های بین شناسه‌ها شود. UUIDها توسط Open Software Foundation (OSF) که بخشی از Distributed Computing Environment (DCE) است استانداردسازی شده‌اند. UUIDها در سال 1996 به عنوان بخشی از استاندارد ISO/IEC 11578:1996 \u0026ldquo;Information technology – Open Systems Interconnection – Remote Procedure Call (RPC)” و همچنین در سال 2005 نیز در استاندارد ITU-T Rec. X.667 | ISO/IEC 9834-8:2005 مستندسازی شده‌اند. همچنین Internet Engineering Task Force (IETF) با انتشار Standards-Track RFC 4122 که از نظر فنی با استاندارد ITU-T Rec. X.667 | ISO/IEC 9834-8 برابر است مستندات مربوط به UUIDها منتشر کرده است. در شیوه متعارف نمایش متنی، شانزده بایت یک شناسه GUID توسط 32 رقم هگزادسیمال (مبنای 16) که در 5 گروه که توسط خط فاصله از یکدیگر جدا شده‌اند در قالب 12-4-4-4-8 که در مجموع 36 کاراکتر (32 کاراکتر الفبایی و چهار خط فاصله) را تشکیل می‌دهد، نشان داده می‌شوند.\n1xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx نمونه 1\n1123E4567-E89B-12D3-A456-426614174000 نمونه 2\n1B4D0257C-BE19-4800-BA11-A09AC2561898 UUIDها دارای سه نوع و پنج نسخه می‌باشند. چهار بیت از رقمی که با M نشان داده شده ‌است، نسخه UUID و رقمی که با N نشان داده شده ‌است، نوع UUID را مشخص می‌کند.\n1xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx در نمونه 1، مقدار M برابر یک و مقدار N برابر a است، به این معنی است که نوع UUID از نوع یک، و نسخه آن نیز ۱ می‌باشد. در نمونه 2، مقدار M برابر 4 و مقدار N برابر b است، به این معنی که نوع UUID از نوع یک و نسخه آن 4 می‌باشد.\nانواع UUID نوع صفر - N = 0..7 برای سازگاری با سیستم قدیمی قالب UUID 1.5 سامانه محاسبات شبکه‌ایApollo در سال 1988 تعریف شده ‌است. در این قالب، 6 بایت اول زمان با طول 48 بیت است (تعداد واحدهای 4 میلی ثانیه از 1 ژانویه 1980 UTC). دو بایت بعدی رزرو شده است و بایت بعدی نوع آدرس‌دهی در شبکه Apollo است. هفت بایت آخر نیز یک شناسه میزبان 56 بیتی است که با توجه به نوع آدرس‌دهی تعیین می‌شود.\nنوع یک - N = 8..b این نوع در استاندارد RFC 4122/DCE 1.1 UUIDs ارجاع داده شده است و نوع رایج UUID می‌باشد.\nنوع دو - N = c..d این نوع که با عنوان GUID توسط شرکت مایکروسافت مطرح شده است اولین بار توسط این شرکت در سیستم عامل ویندوز مورد استفاده قرار گرفته است. نوع یک و دو در نمایش رشته‌ای مشابه هم هستند و تنها در بیت مربوط به نوع باهم متفاوت هستند اما در نمایش دودویی در روش نگهداری نیز باهم متفاوت هستند. در نوع یک از ترتیب بایت big-endian استفاده می‌شود در حالی که در نوع دو از ترتیب بایت little-endian استفاده شده است.\nنوع رزرو شده - N = e..f این بازه برای استفاده در آینده رزرو شده است.\nنسخه های UUID نسخه یک – زمان و آدرس MAC در این نسخه از زمان سیستم و آدرس MAC کارت شبکه که منحصر به فرد برای تولید UUID استفاده می‌شود. با داشتن UUID نسخه 1 با استخراج مقدار timestamp می‌توانید به این موضوع پی ببرید که این UUID چه زمانی تولید شده است. قالب متعارف UUIDهای مبتنی بر زمان به صورت زیر است:\n   نام اندازه (بایت) طول (هگزادسیمال) محتوا     time_low 4 8 عدد صحیحی که ۳۲ بیت پایینی زمان است   time_mid 2 4 عدد صحیحی که ۱۶ بیت میانی زمان است   time_hi_and_version 2 4 ۴ بیت پرارزش، نسخه را مشخص کرده و ۱۲ بیت دیگر ۱۲ بیت بالایی زمان است   clock_seq_hi_and_res clock_seq_low 2 4 بیت‌های ۱ تا ۳ پرارزش نوع UUID و۱۳ تا ۱۵ بیت باقی مانده توالی ساعت است (clock sequence)   node 6 12 شناسه گره ۴۸ بیتی    نسخه دو - زمان و آدرس MAC و نسخه امنیتی DCE این نسخه به صورت خاص در استاندارد RFC 4122 تعریف نشده است و عمومیت ندارد. مشابه نسخه 1 است با این تفاوت که 4 بایت ابتدایی از timestamp با POSIX UID کاربر و بایت پر ‌ارزش توالی ساعت با POSIX UID دامنه جایگزین شده است.\nنسخه سه – MD5 hash و Namespace در این نسخه برای تولید UUID از Hash نمودن نام و شناسه Namespace توسط الگوریتم MD5 استفاده می‌شود. شناسه فضای نام می‌بایست خود منحصر به فرد باشد. مانند آدرس‌ها، نام‌های دامنه، شناسه موجودیت‌ها و نام‌های متمایز X.500 می‌توانند به عنوان فضای نام انتخاب شوند.\nنسخه چهار – تصادفی در این نسخه از اعداد تصادفی برای تولید UUID استفاده می‌شود. از 128 بیت، 6 بیت برای نوع و نسخه UUID رزرو شده و مابقی 122 بیت به صورت تصادفی مقدار می‌گیرند که 2 به توان 122 احتمال را شامل می‌شود. از روش های متفاوتی برای تولید اعداد تصادفی در این نسخه استفاده می‌شود و استاندارد مشخصی در این زمینه وجود ندارد.\nنسخه پنج - SHA-1 hash و Namespace مشابه نسخه 3 است با این تفاوت که از الگوریتم SHA-1 به جای MD5 برای Hash نمودن استفاده می‌شود.\nUUID خالی یا Nil UUID برای UUID یک مقدار خالی یا تهی در نظر گرفته شده است که مقدار آن 00000000-0000-0000-0000-000000000000 می‌باشد.\nصحت یکتایی UUID برخورد (Collisions) هنگامی رخ می‌دهد که یک UUID بیش از یک بار ایجاد شده و به مراجع مختلف اختصاص داده شود. در مورد UUIDهای نسخه 1 و نسخه 2 که با استفاده از آدرس‌های MAC کارت‌های شبکه که منحصر به فرد هستند ساخته شده‌اند، فقط زمانی که پیاده‌سازی استانداردها متفاوت باشد یا ایراداتی در آن وجود داشته باشد احتمال برخورد وجود دارد.\nبرخلاف نسخه 1 و نسخه 2 UUID که از آدرس‌های MAC منحصر به فرد کارت‌های شبکه استفاده می‌کنند، در نسخه 1 و 2 UUID تصادفی و نسخه 3 و 5 که مبتنی بر Hash هستند و نسخه 4 UUID تصادفی، احتمال برخورد وجود دارد. البته با احتمال بسیار کمی که به طور معمول قابل چشم پوشی است. این احتمال را می‌توان دقیقا بر اساس تجزیه و تحلیل پارادوکس تولد محاسبه کرد.\nبه عنوان مثال، تعداد UUIDهای نسخه 4 تصادفی که باید ایجاد شوند تا به احتمال 50٪ حداقل یک برخورد باید تولید شود برابر 2.71 کوئین تیلیون است. این عدد معادل تولید 1 میلیارد UUID در ثانیه برای حدود 85 سال است. فایلی که حاوی این تعداد UUID باشد، با 16 بایت در هر UUID، تقریباً 45 اگزا بایت خواهد بود. احتمال یافتن نسخه تکراری در نسخه 103 تریلیون نسخه 4 UUID یک در میلیارد است.\n","date":"Feb 5, 2020","img":"","permalink":"/posts/uuid-guid/","series":[],"tags":["UUID","GUID"],"title":"UUID چیست؟"},{"categories":["DotNet","CSharp"],"content":"برای کار با آدرس‌های IPv4 و IPv6 در CSharp از کتابخانه System.Net و کلاس IPAddress استفاده می‌شود. به منظور اعتبارسنجی آدرس‌های IP می‌توان از کد زیر استفاده نمود:\n1public static bool IsValidIp(string address) 2{ 3return IPAddress.TryParse(address, out _); 4} به منظور تشخیص نسخه‌ی آدرس‌های IP می‌توان از کد زیر استفاده نمود:\n1public static IpVersion GetIpVersion(string address) 2{ 3if (IPAddress.TryParse(address, out var ipAddress)) 4{ 5if(ipAddress.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork) 6{ 7return IpVersion.IPv4; 8} 9else if(ipAddress.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6) 10{ 11return IpVersion.IPv6; 12} 13} 1415return IpVersion.Unknown; 16} 1718public enum IpVersion 19{ 20Unknown = -1, 21IPv4, 22IPv6 23} آدرس Loopback یک آدرس IP ویژه است که برای آزمایش کارت‌های شبکه، ارتباطات و انتقال در یک کارت شبکه محلی و برنامه‌های کاربردی استفاده می‌شود. این آدرس IP مربوط به Loopback Interface نرم‌افزار کارت شبکه است که هیچ سخت‌افزاری با آن ارتباط ندارد و نیازی به اتصال فیزیکی به شبکه ندارد. برای تشخیص اینکه یک IP از نوع Loopback است یا خیر می‌توان از کد زیر استفاده نمود:\n1public static bool IsLoopback(string address) 2{ 3if (address == \u0026#34;localhost\u0026#34;) 4return true; 56if (IPAddress.TryParse(address, out var ipAddress)) 7{ 8if (ipAddress == IPAddress.Loopback || ipAddress == IPAddress.IPv6Loopback) 9return true; 10} 1112return false; 13} ","date":"Jan 4, 2020","img":"","permalink":"/posts/ip-csharp/","series":[],"tags":["IP","IPHelper","CSharp","DotNet"],"title":"کار با آدرس‌های IP در CSharp"},{"categories":["General"],"content":"IP اختصار عبارت Internet Protocol است که مدل فنی ارسال و دریافت بسته‌ها در اینترنت را به همراه آدرس فرستنده و گیرنده در شبکه‌ی اینترنت یا هر شبکه‌ی کامپیوتری مشخص می‌کند. در حال حاضر دو نسخه برای IP وجود دارد که شامل IPv4 و IPv6 است. IPv6 که Internet Protocol Next Generation نیز خوانده می‌شود، جدیدترین پروتکل اینترنت برای اختصاص آدرس IP است که برای تکمیل و در نهایت جایگزین شدن IPV4 در نظر گرفته شده است. در حال حاضر تا زمان مقتضی شاهد استفاده از هر دو پروتکل به‌صورت هم‌زمان خواهیم بود تا اینکه در نهایت IPv6 به‌صورت کامل جای این پروتکل را بگیرد. IPv6 به این علت طراحی شده است تا علاوه بر داشتن آدرس‌های بیشتر برای اتصال دستگاه‌های بیشتر در مقایسه با IPv4، ظرفیت انتقال اطلاعات در شبکه اینترنت یا همان ترافیک را افزایش دهد. IPv4 یک آدرس اینترنتی 32 بیتی است که به‌صورت اعداد ده‌دهی (دستگاه اعداد مبنای ۱0) در قالب یک رشته نمایش داده می‌شود. یک آدرس اینترنتی مبتنی بر IPv4 به‌صورت چهار دسته (Octet) 8 بیتی نوشته می‌شود که توسط یک نقطه از هم جدا می‌شوند. هر یک از چهار دسته عدد سه‌تایی می‌تواند مقادیر صفر تا 255 را داشته باشد. پس برای هر بخش می توان 256 رقم (2 به توان 8) را در نظر گرفت که با این حساب 2 به توان 32 یا 4294967296 رقم خواهیم داشت. برای مثال آدرس زیر یک آدرس اینترنتی مبتنی بر IPv4 است.\n1172.16.110.1 IPv6 یک آدرس اینترنتی 128 بیتی است که به‌صورت اعداد هگزادسیمال استاندارد (دستگاه اعداد مبنای 16) در قالب یک رشته نمایش داده می‌شود. یک آدرس اینترنتی مبتنی بر IPv6 به‌صورت هشت دسته (Octet) 16 بیتی نوشته می‌شود که توسط یک کالِن از هم جدا می‌شوند. هر یک از هشت دسته 8 بیتی می‌تواند مقادیر 0000 تا FFFF را داشته باشد. پس برای هر بخش می‌توان 65,536 رقم (2 به توان 16) را در نظر گرفت که با این حساب 2 به توان 128 یا 340,282,366,920,938,463,463,374,607,431,768,211,456 عدد خواهیم داشت که حدود 7,922,816,251,426,433,759,354 برابر بیشتر از IPv4 می‌باشد. برای مثال آدرس زیر یک آدرس اینترنتی مبتنی بر IPv6 است.\n165b3:b834:45a3:0000:0000:762e:0270:5224 در IPv6 بخش‌هایی که تمام رقم‌های آن صفر می‌باشند را می‌توان حذف نمود و به جای آن‌ها از کاراکتر : استفاده کرد. به عنوان مثال آدرس‌های زیر مشابه هم هستند:\n12001:cdba:0000:0000:0000:0000:3257:9652 232001:cdba:0:0:0:0:3257:9652 452001:cdba::3257:9652 ","date":"Jan 3, 2020","img":"","permalink":"/posts/ip/","series":[],"tags":["IP"],"title":"آدرس IP چیست؟"},{"categories":null,"content":"من آرمان حسن پور هستم. از سال 1390 شروع به برنامه‌نویسی کردم. با زبان‌های برنامه‌نویسی زیادی کار کردم ولی بیشتر از زبان، توانایی حل مسئله برام ارزشمند بوده و هست. بیشتر فعالیتم در حوزه‌های مالی و بانکی بوده و همچنین در مدیریت بانک‌های اطلاعاتی دارای مهارت هستم. علاقه‌مند به یادگیری و کسب مهارت در حوزه‌های جدید فناوری اطلاعات هستم و تلاش می‌کنم که خودمو به روز نگه داشته باشم.\n","date":"Feb 28, 2019","img":"","permalink":"/about/","series":null,"tags":null,"title":"در مورد من"},{"categories":null,"content":"","date":"Jan 1, 0001","img":"","permalink":"/contact/","series":null,"tags":null,"title":"تماس با من"}]