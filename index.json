[{"categories":["Oracle","Java","SQL"],"content":"هرچند SQL بسیاری از نیازمندی‌های برنامه‌نویسان را در زمینه‌ی کار با داده‌ها برطرف می‌نماید اما در مواقعی که نیاز به پیاده‌سازی توابع پیچیده یا تبدیل انواع خاص و سفارشی بهم داریم نیاز به استفاده از یک زبان‌ برنامه‌نویسی سطح بالا وجود دارد. هرچند استفاده از زبان‌های برنامه‌نویسی دیگر در بانک‌های اطلاعاتی رابطه‌ای مرسوم نیست و حتی در برخی موارد ممکن است کارایی سیستم را کاهش دهد اما اگر در جای درستی استفاده شود مطمئنا باعث بهبود عملکرد کلی سیستم می‌شود. بدین منظور، در بانک اطلاعاتی Oracle قابلیت استفاده از زبان برنامه‌نویسی Java وجود دارد و می‌توان متدهای نوشته شده با این زبان را با SQL ادغام و اجرا نمود.\nبه منظور استفاده از متدهای Java در Oralce چندین روش پیشنهاد می‌شود:\nاستفاده از PL/SQL Wrappers پشتیبانی از JNI استفاده از SQLJ و JDBC استفاده از رابط خط فرمان استفاده از Stub در سمت کلاینت در این مطلب از ساده‌ترین روش یعنی PL/SQL Wrappers برای فراخوانی متدهای Java استفاده می‌نماییم. شما می‌توانید متدهای کامپایل‌شده Java را به همان روشی که توابع و روال‌های ذخیره شده (Stored Procedure) در PL/SQL اجرا می‌شوند، اجرا کنید. در بانک اطلاعاتی Oracle، متدهای Java معمولا از طریق رابط PL/SQL فراخوانی می‌شود. برای فراخوانی یک متد کامپایل‌شده Java، باید آن را از طریق \u0026ldquo;مشخصات فراخوانی\u0026rdquo; (Call Specification) منتشر کنید. مثال زیر نحوه‌ی ایجاد، resolve، بارگذاری و انتشار یک متد ساده کامپایل‌شده Java را نشان می‌دهد که یک رشته را باز می‌گرداند: 1-\tکلاس Hello را به شکل زیر پیاده‌سازی می‌کنیم و آن را با نام Hello.java ذخیره می‌نماییم. توجه داشته باشید که به منظور فراخوانی متدهای Java نیاز است آن‌ها را به صورت static پیاده‌سازی نمایید.\n1public class Hello 2{ 3 public static String world() 4 { 5 return \u0026#34;Hello world\u0026#34;; 6 } 7} 2-\tسپس کلاس مورد نظر را با کامپایلر (Compiler) استاندارد Java، کامپایل می‌نماییم:\n1javac Hello.java با ایجاد این دستور، کامپایلر یک فایل باینری Java (در این مورد Hello.class) را تولید می‌کند. ایده‌ی خوبی است که CLASSPATH را در خط فرمان با دستور javac مشخص کنید، مخصوصا هنگام نوشتن اسکریپت‌های shell یا ایجاد فایل. شما باید مکانی که این کد Java در آن اجرا می‌شود را تعیین نمایید. اگر Hello.class را روی سیستم کلاینت خود اجرا می‌کنید، CLASSPATH را برای تمام کلاس‌های اصلی وابسته که Hello.class برای اجرا نیاز دارد جستجو می‌کند. این جستجو باید منجر به یافتن کلاس‌های وابسته در یکی از موارد زیر شود:\nبه عنوان فایل‌های جداگانه در یک یا چند دایرکتوری، جایی که دایرکتوری‌ها در CLASSPATH مشخص شده‌اند. در فایل‌های jar یا zip، که دایرکتوری‌های حاوی این فایل‌ها در CLASSPATH مشخص شده‌اند. 3-\tدر مورد resolver کلاس Hello تصمیم بگیرید. در این مورد، Hello.class را در سرور بارگذاری کنید، جایی که در بانک اطلاعاتی به عنوان یک شی طرح Java ذخیره می‌شود. هنگامی که متد world را فراخوانی می‌کنید، Oracle JVM کلاس‌های وابسته لازم مانند String را با استفاده از یک resolver مکان‌یابی می‌کند. در این مورد، Oracle JVM از resolver پیش‌فرض استفاده می‌کند. resolver پیش‌فرض این کلاس‌ها را ابتدا در اسکیمای (schema) فعلی و سپس در PUBLIC جستجو می‌کند. تمام کتابخانه‌های کلاس اصلی، از جمله java.lang، در PUBLIC یافت می‌شوند. ممکن است لازم باشد resolverهای مختلفی را مشخص کنید. این امکان وجود دارد که با استفاده از ابزار loadjava، مشکلات را زودتر و نه در زمان اجرا ردیابی کنید.\n4-\tکلاس را با استفاده از ابزار loadjava روی سرور بارگذاری کنید. شما باید نام کاربری و رمز عبور بانک اطلاعاتی مربوطه را نیز مشخص کنید. ابزار loadjava را به صورت زیر اجرا کنید:\n1loadjava -user user/password@ip:1521:database Hello.class با استفاده از ویژگی verbose- در ابزار loadjava می‌توان پیغام‌های مرتبط با بارگذاری کلاس را مشاهده نمود. 5-\tمتد کامپایل‌شده را از طریق مشخصات فراخوانی (Call Specification) منتشر کنید. برای فراخوانی متد مربوطه Java با فراخوانی SQL، باید متد را با مشخصات فراخوانی منتشر کنید. مشخصات فراخوانی آرگومان‌هایی را که متد می‌گیرد و انواع SQL که باز می‌گرداند را تعریف می‌کند. مشخصات فراخوانی امکانی برای پیوند دادن فراخوانی‌های بین زبانی با هم به شیوه‌ای ثابت فراهم می‌کند.\n1CREATE OR REPLACE FUNCTION FUNC_HELLO_WORD RETURN VARCHAR2 AS 2LANGUAGE JAVA NAME \u0026#39;Hello.world () return java.lang.String\u0026#39;; 6-\tتابع مربوطه را به شکل زیر فراخوانی کنید:\n1DECLARE v_Return varchar2(1000); 2BEGIN 3 v_Return := FUNC_HELLO_WORD(); 4 DBMS_OUTPUT.PUT_LINE(\u0026#39;v_Return = \u0026#39; || v_Return); 5END; ","date":"Jan 15, 2023","img":"","permalink":"/posts/oracle-load-java/","series":[],"tags":["Oracle","Java","LoadJava","SQL"],"title":"استفاده از زبان برنامه‌نویسی Java در بانک اطلاعاتی Oracle"},{"categories":["SQLServer","SQL"],"content":"برای تهیه‌ی صورت حساب بانکی (گردش حساب) در SQL روش‌های مختلفی وجود دارد که ما در این مطلب یکی از روش‌های آن را پیاده‌سازی می‌کنیم.\nبه عنوان یک مثال جدولی برای نگهداری تراکنش‌ها ایجاد می‌نماییم:\n1CREATE TABLE dbo.Transactions 2([Row] integer, [Type] integer, [Amount] DECIMAL(18,0)) سپس آن را با مقادیر زیر مقداردهی می‌کنیم:\n1INSERT INTO dbo.Transactions ([Row], [Type], [Amount]) 2VALUES (1, 1, 1000) 3 4INSERT INTO dbo.Transactions ([Row], [Type], [Amount]) 5VALUES (2, 1, 2000) 6 7INSERT INTO dbo.Transactions ([Row], [Type], [Amount]) 8VALUES (3, -1, 1000) 9 10INSERT INTO dbo.Transactions ([Row], [Type], [Amount]) 11VALUES (3, 1, 3000) سه متغیر به نام‌های SumCredit، SumDebit و Balance را به عنوان جمع بستانکار از قبل، جمع بدهکار از قبل و مانده از قبل تعریف می‌کنیم. در صورتی که همه تراکنش‌ها در یک جدول است و جدول دیگری برای تراکنش‌های قبلی نداریم مقدار این سه متغییر را می‌توان برابر صفر قرار داد یا آن‌ها را با صفر جایگزین نمود.\n1DECLARE @SumCredit DECIMAL(18,0); 2SET @SumCredit = 8000; 3 4DECLARE @SumDebit DECIMAL(18,0); 5SET @SumDebit = 2000; 6 7DECLARE @Balance DECIMAL(18,0); 8SET @Balance = 5000; در آخر هم به منظور نمایش صورت حساب به روش زیر عمل می کنیم:\n1SELECT 2\t[Row] AS Row, 3\t[Type] AS Type, 4\t[Amount] AS Amount, 5\t((SUM(([Type]*[Amount])*(-1)) OVER (ORDER BY [Row])) + @Balance) AS Balance, 6\t((SUM(CASE WHEN [Type] = -1 THEN [Amount] ELSE 0 END) OVER (ORDER BY [Row])) + @SumCredit) AS Credit, 7\t((SUM(CASE WHEN [Type] = 1 THEN [Amount] ELSE 0 END) OVER (ORDER BY [Row])) + @SumDebit) AS Debit 8FROM dbo.Transactions ","date":"Jul 2, 2020","img":"","permalink":"/posts/sql-server-turnover/","series":[],"tags":["SQLServer","SQL","Turn Over","Balance Sheet"],"title":"صورت حساب در SQL"},{"categories":["Shetab"],"content":"سامانه‌ی شتاب به عنوان تنها سوئیچ ملی بین بانکی کشور، سیستمی مبتنی بر کارت‌ بوده و وظیفه تبادل تراکنش‌های بین بانکی و اعمال مقررات بانک مرکزی به عنوان مقام ناظر را بر عهده دارد و سطح گستردگی این سامانه شامل کلیه بانک‌های کشور است که با اتصال به چند سوئیچ برون‌مرزی، کل تراکنش‌های کارتی کشور را پوشش می‌دهد.\nسامانه‌ی شتاب جهت تبادل پیام‌ها و تراکنش‌های مالی از استاندارد ISO8583 استفاده کرده و قابلیت پشتیبانی از سه ویرایش این استاندارد که در سال‌های 1987، 1993 و 2003 ارائه گردیده است را دارد. بانک مرکزی در سال 1392 با ارائه نسخه 7 شتاب بانک‌ها را ملزم به استفاده از ویرایش 2003 این استاندارد کرده است. شتاب وظیفه انتقال امن اطلاعات و داده‌های مربوط به تراکنش‌های ‌مالی و غیرمالی به بانک‌های صادرکننده و یا پذیرنده را دارد. این مرکز با استفاده از سخت افزارها، نرم افزارها و شبکه‌ی ارتباطی خود، پیام‌ها و داده‌های اخذ شده از اعضا را پذیرش کرده، آن‌ها را ثبت، مسیریابی و به بانک‌های صادرکننده یا پذیرنده ارسال می‌نماید. نتیجه این اقدامات دریافت خدمات مبتنی بر کارت توسط دارندگان کارت بانک‌ها از تجهیزات سایر بانک‌ها می‌باشد. شتاب برای نظارت بیشتر بر شبکه‌ی بانکی با ارتباط با مرکز کنترل و نظارت اعتباری (مکنا) کلیه سوابق مشتریان و قوانین بالا دستی را کنترل و بر تراکنش‌های تبادلی در این شبکه نظارت دارد.\n","date":"Jun 3, 2020","img":"","permalink":"/posts/shetab-info/","series":[],"tags":["شتاب","Shetab"],"title":"سامانه شتاب"},{"categories":["SQLServer","SQL"],"content":"یکی از موارد پُرکاربرد در مهندسی معکوس نرم‌افزارهای دارای بانک اطلاعاتی جستجوی یک مقدار در کل جدول‌های یک بانک اطلاعاتی است.\nبه این منظور می‌توان از کد زیر استفاده نمود:\n1DECLARE @SearchStr nvarchar(100) 2SET @SearchStr = \u0026#39;## YOUR STRING HERE ##\u0026#39; 3 4CREATE TABLE #Results (ColumnName nvarchar(370), ColumnValue nvarchar(3630)) 5 6SET NOCOUNT ON 7 8DECLARE @TableName nvarchar(256), 9\t@ColumnName nvarchar(128), 10\t@SearchStr2 nvarchar(110) 11 12SET @TableName = \u0026#39;\u0026#39; 13 14SET @SearchStr2 = QUOTENAME(\u0026#39;%\u0026#39; + @SearchStr + \u0026#39;%\u0026#39;,\u0026#39;\u0026#39;\u0026#39;\u0026#39;) 15 16WHILE @TableName IS NOT NULL 17BEGIN 18 SET @ColumnName = \u0026#39;\u0026#39; 19 SET @TableName = 20 ( 21 SELECT MIN(QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME)) 22 FROM INFORMATION_SCHEMA.TABLES 23 WHERE TABLE_TYPE = \u0026#39;BASE TABLE\u0026#39; 24 AND QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME) \u0026gt; @TableName 25 AND OBJECTPROPERTY( 26 OBJECT_ID( 27 QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME) 28 ), \u0026#39;IsMSShipped\u0026#39; 29 ) = 0 30 ) 31 32 WHILE (@TableName IS NOT NULL) AND (@ColumnName IS NOT NULL) 33 BEGIN 34 SET @ColumnName = 35 ( 36 SELECT MIN(QUOTENAME(COLUMN_NAME)) 37 FROM INFORMATION_SCHEMA.COLUMNS 38 WHERE TABLE_SCHEMA = PARSENAME(@TableName, 2) 39 AND TABLE_NAME = PARSENAME(@TableName, 1) 40 AND DATA_TYPE IN (\u0026#39;char\u0026#39;, \u0026#39;varchar\u0026#39;, \u0026#39;nchar\u0026#39;, \u0026#39;nvarchar\u0026#39;, \u0026#39;int\u0026#39;, \u0026#39;decimal\u0026#39;) 41 AND QUOTENAME(COLUMN_NAME) \u0026gt; @ColumnName 42 ) 43 44 IF @ColumnName IS NOT NULL 45 BEGIN 46 INSERT INTO #Results 47 EXEC 48 ( 49 \u0026#39;SELECT \u0026#39;\u0026#39;\u0026#39; + @TableName + \u0026#39;.\u0026#39; + @ColumnName + \u0026#39;\u0026#39;\u0026#39;, LEFT(\u0026#39; + @ColumnName + \u0026#39;, 3630) FROM \u0026#39; + @TableName + \u0026#39; (NOLOCK) \u0026#39; + 50 \u0026#39; WHERE \u0026#39; + @ColumnName + \u0026#39; LIKE \u0026#39; + @SearchStr2 51 ) 52 END 53 END 54END 55 56SELECT ColumnName, ColumnValue FROM #Results 57 58DROP TABLE #Results همچنین می‌توان به منظور قابلیت استفاده مجدد، کد بالا را به صورت Stored Procedure نیز پیاده‌سازی نمود:\n1CREATE PROC SearchAllTables 2( 3 @SearchStr nvarchar(100) 4) 5AS 6BEGIN 7 CREATE TABLE #Results (ColumnName nvarchar(370), ColumnValue nvarchar(3630)) 8 9 SET NOCOUNT ON 10 11 DECLARE @TableName nvarchar(256), 12\t@ColumnName nvarchar(128), 13\t@SearchStr2 nvarchar(110) 14\t15 SET @TableName = \u0026#39;\u0026#39; 16 SET @SearchStr2 = QUOTENAME(\u0026#39;%\u0026#39; + @SearchStr + \u0026#39;%\u0026#39;,\u0026#39;\u0026#39;\u0026#39;\u0026#39;) 17 18 WHILE @TableName IS NOT NULL 19 BEGIN 20 SET @ColumnName = \u0026#39;\u0026#39; 21 SET @TableName = 22 ( 23 SELECT MIN(QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME)) 24 FROM INFORMATION_SCHEMA.TABLES 25 WHERE TABLE_TYPE = \u0026#39;BASE TABLE\u0026#39; 26 AND QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME) \u0026gt; @TableName 27 AND OBJECTPROPERTY( 28 OBJECT_ID( 29 QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME) 30 ), \u0026#39;IsMSShipped\u0026#39; 31 ) = 0 32 ) 33 34 WHILE (@TableName IS NOT NULL) AND (@ColumnName IS NOT NULL) 35 BEGIN 36 SET @ColumnName = 37 ( 38 SELECT MIN(QUOTENAME(COLUMN_NAME)) 39 FROM INFORMATION_SCHEMA.COLUMNS 40 WHERE TABLE_SCHEMA = PARSENAME(@TableName, 2) 41 AND TABLE_NAME = PARSENAME(@TableName, 1) 42 AND DATA_TYPE IN (\u0026#39;char\u0026#39;, \u0026#39;varchar\u0026#39;, \u0026#39;nchar\u0026#39;, \u0026#39;nvarchar\u0026#39;, \u0026#39;int\u0026#39;, \u0026#39;decimal\u0026#39;) 43 AND QUOTENAME(COLUMN_NAME) \u0026gt; @ColumnName 44 ) 45 46 IF @ColumnName IS NOT NULL 47 BEGIN 48 INSERT INTO #Results 49 EXEC 50 ( 51 \u0026#39;SELECT \u0026#39;\u0026#39;\u0026#39; + @TableName + \u0026#39;.\u0026#39; + @ColumnName + \u0026#39;\u0026#39;\u0026#39;, LEFT(\u0026#39; + @ColumnName + \u0026#39;, 3630) FROM \u0026#39; + @TableName + \u0026#39; (NOLOCK) \u0026#39; + 52 \u0026#39; WHERE \u0026#39; + @ColumnName + \u0026#39; LIKE \u0026#39; + @SearchStr2 53 ) 54 END 55 END 56 END 57 58 SELECT ColumnName, ColumnValue FROM #Results 59 DROP TABLE #Results 60END ","date":"Feb 9, 2020","img":"","permalink":"/posts/sql-server-search-in-tables/","series":[],"tags":["SQLServer","SQL"],"title":"جستجو در همه جدول‌ها در SQL Server"},{"categories":["DotNet","CSharp","SQLServer","SQL"],"content":"SQL Server به منظور ارتقا در مدل برنامه‌نویسی بانک اطلاعاتی خود از نسخه 2005 تکنولوژی SQL CLR را معرفی نمود. این تکنولوژی همچنین با اسامی CLR Integrated ،CLR Enabled و CLR Embedded نیز شناخته می‌شود. هدف آن این است که شما بتوانید اشیاء بانک اطلاعاتی از قبیل روال‌های ذخیره شده (Stored Procedure) ، توابع (Function) و تریگرها (Trigger) را با استفاده از CSharp و یا VB ایجاد کرده و آن را در SQL Server مورد استفاده قرار دهید.\nتکنولوژی SQL CLR با میزبانی کردن از (dotNET Common Language Runtime) یا همان محیط زمان اجرای dotNET در SQL Server، به مدیران بانک اطلاعاتی اجازه می‌دهد تا از قابلیت‌های موجود در dotNET برای تعریف اشیاء بانک اطلاعاتی استفاده کنند. این قابلیت توسط فضاهای نام System.Data ،System.Data.Sql و Microsoft.SqlServer.Server که در اسمبلی (assembly) System.Data.dll در dotNET قرار داده شده‌اند، پشتیبانی می‌گردند. ایجاد اشیاء بانک اطلاعاتی با استفاده از امکان SQL CLR، طی مراحل زیر ممکن می‌گردند:\nپیاده‌سازی کدها در CSharp یا VB در dotNET و کامپایل آن بارگذاری و اجرای کد کامپایل شده در مرحله قبل در SQL Server فعال سازی امکان SQL CLR در بانک اطلاعاتی ایجاد اسمبلی از کد مزبور در بانک اطلاعاتی ایجاد شی بانک اطلاعاتی از اسمبلی مرحله قبل پیاده‌سازی کدها در CSharp یا VB در dotNET و کامپایل آن به عنوان مثال کد مورد نظر خود را در کلاسی با نام StoredProcedures و در تابع SP1 نوشته و آن را کامپایل می‌کنیم. کد کامپایل شده را (StoredProcedures.dll) باید در مرحله بعد در SQL Server بارگذاری کنیم. البته کد زیر یک مثال hello world بوده و تنها به منظور آشنایی با نحوه انجام کار می‌باشد. از تمامی قابلیت‌ها و کلاس‌های موجود در dotNET می‌توان در این کلاس استفاده نمود.\n1using System; 2using System.Data; 3using Microsoft.SqlServer.Server; 4using System.Data.SqlTypes; 5 6public class StoredProcedures 7{ 8 [Microsoft.SqlServer.Server.SqlProcedure] 9 public static void SP1() 10 { 11 SqlContext.Pipe.Send(\u0026#34;Hello world!\\n\u0026#34;); 12 } 13} فعال‌سازی امکان CLR SQL در بانک اطلاعاتی امکان CLR SQL در SQL Server به صورت پیش فرض غیرفعال است و برای فعال‌سازی آن باید کد زیر را اجرا کرد:\n1sp_configure \u0026#39;show advanced options\u0026#39;, 1 2RECONFIGURE 3GO 4 5sp_configure \u0026#39;clr enabled\u0026#39;, 1 6RECONFIGURE 7GO 8 9sp_configure \u0026#39;show advanced options\u0026#39;, 0 10RECONFIGURE 11GO برای غیرفعال‌سازی هم کد زیر را باید اجرا نمود:\n1sp_configure \u0026#39;show advanced options\u0026#39;, 1 2RECONFIGURE 3GO 4 5sp_configure \u0026#39;clr enabled\u0026#39;, 0 6RECONFIGURE 7GO 8 9sp_configure \u0026#39;show advanced options\u0026#39;, 0 10RECONFIGURE 11GO برای اینکه فعال یا غیرفعال بودن SQL CLR را در SQL SERVER بررسی نماییم باید کد زیر را اجرا نمود:\n1SELECT name 2 ,CAST(value AS int) AS value_configured 3 ,CAST(value_in_use AS int) AS value_in_use 4FROM sys.configurations 5WHERE name = \u0026#39;clr enabled\u0026#39; ایجاد اسمبلی در بانک اطلاعاتی گام بعدی ایجاد اسمبلی در بانک اطلاعاتی از روی کد کامپایل شده است.\n1CREATE ASSEMBLY QClrIntegration 2\tFROM \u0026#39;H:\\Clr\\StoredProcedures.dll\u0026#39; 3\tWITH Permission_set = safe 4GO با توجه به کدی که نوشته‌ایم و برای کنترل دسترسی کد CLR به دیگر کدها از PERMISSION_SET استفاده می‌گردد:\nویژگی SAFE به اسمبلی‌ها اجازه می‌دهد که تنها محاسبات محلی و دسترسی به فایل‌های محلی را داشته باشد. ویژگی EXTERNAL_ACCESS مشابه ویژگی قبلی با این تفاوت که اسمبلی می‌تواند به منابع شبکه دسترسی داشته باشد. ویژگی UNSAFE اجازه دسترسی نامحدود به منابع و کدهای غیر از dotNet و مدیریت نشده (Unmanaged Code) را هم می‌دهد. برای استفاده از ویژگی UNSAFE باید ویژگی اعتماد (trustworthy) را در بانک اطلاعاتی فعال نمود. این ویژگی مشخص می‌کند که بانک اطلاعاتی به کدهای بیرونی اعتماد دارد (البته توصیه نمی‌شود). در غیر این صورت با فعال‌سازی خصوصیت UNSAFE خطا اعلام می‌شود.\n1ALTER DATABASE DB_NAME 2\tSET trustworthy ON 3GO\tبه طور کلی فعال کردن استفاده از SQL CLR سطح حملات به SQL Server را وسیع‌تر می‌کند و آن را از نظر اسمبلی‌های غیر عمدی و مخرب در معرض خطر قرار می‌دهد. با توجه به ضرورت استفاده از SQL CLR بسیاری از چک لیست‌های امنیتی فقط اسمبلی‌های ایجاد شده با دسترسی SAFE را مجاز می‌دانند و اسمبلی‌های ایجاد شده با دسترسی‌های UNSAFE و EXTERNAL_ACCESS را خطرناک می‌شمارند.\nایجاد شی بانک اطلاعاتی از اسمبلی مرحله قبل حال می‌توان از اسمبلی ایجاد شده در مرحله قبل برای ایجاد روال ذخیره شده (Stored Procedure) و یا تابع (Function) مورد نظر استفاده نمود. چون در مرحله‌ی قبل ما کلاسی از نوع Stored Procedure ایجاد کردیم، در SQL Server نیز برای استفاده از آن یک روال ذخیره شده ایجاد می‌کنیم.\n1CREATE PROCEDURE hello 2AS 3EXTERNAL NAME helloworld.StoredProcedures.SP1 4GO با اجرای این روال ذخیره شده، کد نوشته شده در تابع sp1 اجرا می‌گردد:\n1EXEC hello 2 3-- Hello world! برای حذف ابتدا باید شی‌هایی که ارجاعی از اسمبلی حذف و سپس خود اسمبلی حذف گردد:\n1DROP PROCEDURE hello 2GO 3 4DROP ASSEMBLY helloworld 5GO ","date":"Feb 7, 2020","img":"","permalink":"/posts/sql-server-clr/","series":[],"tags":["SQLServer","SQL","CLR","CSharp","DotNet","SQL CLR","CLR Integrated","CLR Embedded"],"title":"استفاده از CLR در SQL Server"},{"categories":["DotNet","CSharp"],"content":"برای ایجاد و استفاده از UUID در زبان برنامه‌نویسی CSharp از ساختار Guid موجود در کتابخانه System استفاده می‌شود.\nبرای ایجاد که یک Guid در زبان برنامه‌نویسی CSharp می توان از کد زیر استفاده نمود:\n1public static Guid NewGuid() 2{ 3 return Guid.NewGuid(); 4} guid ایجاد شده در این روش از نوع و نسخه چهارم UUID است و به صورت تصادفی تولید می‌شود. برای تولید guid به صورت ترتیبی می‌توان از کد زیر استفاده نمود:\n1public static Guid NewSequentialGuid() 2{ 3 var uid = Guid.NewGuid().ToByteArray(); 4 var binDate = BitConverter.GetBytes(DateTime.UtcNow.Ticks); 5 6 var secuentialGuid = new byte[uid.Length]; 7 8 secuentialGuid[0] = uid[0]; 9 secuentialGuid[1] = uid[1]; 10 secuentialGuid[2] = uid[2]; 11 secuentialGuid[3] = uid[3]; 12 secuentialGuid[4] = uid[4]; 13 secuentialGuid[5] = uid[5]; 14 secuentialGuid[6] = uid[6]; 15 16 // set the first part of the 8th byte to \u0026#39;1100\u0026#39; so 17 // later we\u0026#39;ll be able to validate it was generated by us 18 19 secuentialGuid[7] = (byte)(0xc0 | (0xf \u0026amp; uid[7])); 20 21 // the last 8 bytes are sequential, 22 // it minimizes index fragmentation 23 // to a degree as long as there are not a large 24 // number of Secuential-Guids generated per millisecond 25 26 secuentialGuid[9] = binDate[0]; 27 secuentialGuid[8] = binDate[1]; 28 secuentialGuid[15] = binDate[2]; 29 secuentialGuid[14] = binDate[3]; 30 secuentialGuid[13] = binDate[4]; 31 secuentialGuid[12] = binDate[5]; 32 secuentialGuid[11] = binDate[6]; 33 secuentialGuid[10] = binDate[7]; 34 35 return new Guid(secuentialGuid); 36} برای بررسی رشته‌ای که حاوی guid است به ساختار guid می‌توان از کد زیر استفاده نمود:\n1public static bool IsGuid(string guidString) 2{ 3 return Guid.TryParse(guidString, out _); 4} برای بررسی اینکه آیا مقدار guid مورد نظرتان یک guid خالی است یا خیر می‌توان از کد زیر استفاده نمود:\n1public static bool IsEmptyGuid(Guid guid) 2{ 3 return guid == Guid.Empty; 4} ","date":"Feb 6, 2020","img":"","permalink":"/posts/uuid-guid-csharp/","series":[],"tags":["UUID","GUID","CSharp","DotNet"],"title":"کار با UUID در CSharp"},{"categories":["DotNet","CSharp"],"content":"برای کار با آدرس‌های IPv4 و IPv6 در CSharp از کتابخانه System.Net و کلاس IPAddress استفاده می‌شود.\nبه منظور اعتبارسنجی آدرس‌های IP می‌توان از کد زیر استفاده نمود:\n1public static bool IsValidIp(string address) 2{ 3 return IPAddress.TryParse(address, out _); 4} به منظور تشخیص نسخه‌ی آدرس‌های IP می‌توان از کد زیر استفاده نمود:\n1public static IpVersion GetIpVersion(string address) 2{ 3 if (IPAddress.TryParse(address, out var ipAddress)) 4 { 5 if(ipAddress.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork) 6 { 7 return IpVersion.IPv4; 8 } 9 else if(ipAddress.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6) 10 { 11 return IpVersion.IPv6; 12 } 13 } 14 15 return IpVersion.Unknown; 16} 17\t18public enum IpVersion 19{ 20 Unknown = -1, 21 IPv4, 22 IPv6 23} آدرس Loopback یک آدرس IP ویژه است که برای آزمایش کارت‌های شبکه، ارتباطات و انتقال در یک کارت شبکه محلی و برنامه‌های کاربردی استفاده می‌شود. این آدرس IP مربوط به Loopback Interface نرم‌افزار کارت شبکه است که هیچ سخت‌افزاری با آن ارتباط ندارد و نیازی به اتصال فیزیکی به شبکه ندارد. برای تشخیص اینکه یک IP از نوع Loopback است یا خیر می‌توان از کد زیر استفاده نمود:\n1public static bool IsLoopback(string address) 2{ 3 if (address == \u0026#34;localhost\u0026#34;) 4 return true; 5 6 if (IPAddress.TryParse(address, out var ipAddress)) 7 { 8 if (ipAddress == IPAddress.Loopback || ipAddress == IPAddress.IPv6Loopback) 9 return true; 10 } 11 12 return false; 13} ","date":"Jan 4, 2020","img":"","permalink":"/posts/ip-csharp/","series":[],"tags":["IP","IPHelper","CSharp","DotNet"],"title":"کار با آدرس‌های IP در CSharp"},{"categories":["SQLServer","SQL"],"content":"با توجه به نسخه SQL Server روش جستجو و بازگرداندن لیستی از تمام جدول‌های ایجاد شده توسط کاربر کمی متفاوت است. در این مطلب به طور خلاصه پرس‌و‌جوهایی را بررسی خواهیم کرد که می‌توانند برای بازیابی لیست جدول‌ها در همه نسخه‌ها استفاده شوند.\nنسخه 2000 برای نسخه‌های قدیمی‌تر SQL Server (مانند SQL Server 2000، اگرچه این روش در SQL Server 2005 برای سازگاری با نسخه‌های قبلی نیز پشتیبانی می‌شود)، باید از یک View به نام SYS.SYSOBJECTS استفاده نمایید. این View شامل یک ردیف برای هر شی می‌باشد که در بانک اطلاعاتی ایجاد شده است، از جمله Viewها، stored procedureها و جدول‌ها. جدول‌هایی که کاربر ایجاده کرده است نیز قابل تفکیک از جدول‌های سیستمی هستند.\nدر SYSOBJECTS ستون‌های دیگری نیز وجود دارد زیرا باید اطلاعاتی در مورد هر چیزی که در طول زمان به بانک اطلاعاتی اضافه شده است را در خود نگهداری نماید. بنابراین، برای یافتن لیستی از جدول‌های ایجاد شده توسط کاربر (و تفکیک آن از جدول‌های سیستم)، باید نتایجی را پیدا کنیم که در آن ستون xtype (که نوع شی را برای آن ردیف مشخص می‌کند) برابر با مقدار U است که به معنای جدول‌های کاربر است. دستور TSQL حاصل باید به شکل زیر باشد:\n1SELECT 2 * 3FROM 4 SYSOBJECTS 5WHERE 6 xtype = \u0026#39;U\u0026#39;; 7GO از آنجایی که SYSOBJECTS بخشی از فضای نام SYS است، هنگام پرس‌و‌جو از SYSOBJECTS، تعیین اینکه SYSOBJECTS بخشی از فضای نام سراسری SYS است، غیر ضروری است، بنابراین می‌توانیم آن را همانطور که در مثال بالا نشان داده شده است حذف نماییم.\nمثال بالا لیستی از نتایج تمامی جدول‌ها ایجاد شده توسط کاربر را باز می‌گرداند. از آنجایی که تعداد ستون‌‌هایی که هنگام پرس‌و‌جو از همه ستون‌ها بازگردانده می‌شود بسیار زیاد است، ممکن است بخواهید نتایج را تنها با مشاهده ستون نام و cdate (تاریخ ایجاد) محدود کنید:\n1SELECT 2 name, 3 crdate 4FROM 5 SYSOBJECTS 6WHERE 7 xtype = \u0026#39;U\u0026#39;; 8GO نسخه 2005 به بالا فهرست کردن نام تمام جدول‌ها در SQL Server در نسخه‌های 2005 به بالا با استفاده از یک View به نام INFORMATION_SCHEMA امکان‌پذیر است که به طور خودکار در SQL Server ساخته می‌شود. این View به شما این امکان را می‌دهد که به راحتی طیف گسترده‌ای از metadata از اشیاء موجود در SQL Server را مشاهده نمایید از جمله اطلاعاتی در مورد ستون‌ها، stored procedureها، و حتی جدول‌ها. در هنگام استفاده از این View چهار ستون بازگردانده می‌شود، که مهمترین ستون آن TABLE_TYPE است که تعیین می‌کند موجودیت آن سطر یک جدول یا یک View است.\nبرای برگرداندن همه جدول‌ها و Viewها در یک پرس‌و‌جو، عبارت TSQL زیر را اجرا کنید:\n1SELECT 2 * 3FROM 4 INFORMATION_SCHEMA.TABLES; 5GO برای برگرداندن همه جدول‌ها و Viewهای یک بانک اطلاعاتی در یک پرس‌و‌جو، عبارت TSQL زیر را اجرا کنید:\n1SELECT 2 * 3FROM 4 databaseName.INFORMATION_SCHEMA.TABLES; 5GO اگر می‌خواهید فقط جدول‌های کاربر را مشاهده نمایید عبارت TSQL زیر را اجرا کنید:\n1SELECT 2 * 3FROM 4 databaseName.INFORMATION_SCHEMA.TABLES 5WHERE 6 TABLE_TYPE = \u0026#39;BASE TABLE\u0026#39;; 7GO ","date":"Aug 1, 2019","img":"","permalink":"/posts/sql-server-show-all-tables/","series":[],"tags":["SQLServer","SQL"],"title":"نمایش لیست همه جدول‌ها در SQL Server"},{"categories":["General","Design Patterns"],"content":"در طول زمان برنامه‌نویسان برای توسعه‌ی نرم‌افزارها با مشکلات مختلفی مواجه می‌شدند. بسیاری از این مشکلات مستقل از زبان‌های برنامه‌نویسی و مشابه هم بودند. بنابراین برای حل این مشکلات راه‌حل‌های مختلفی ارائه شد که به بهترین روش حل و رفع این مشکلات الگوهای طراحی یا Design Pattern می‌گویند. به عبارت دیگر مجموعه‌‌‌ای از بهترین راه‌‌حل‌های مشکلات متداول در فرآیند برنامه‌نویسی نرم‌افزار را الگوهای طراحی می‌نامند. الگوهای طراحی برای حل مشکلات رایج در برنامه‌نویسی شی‌گرا به وسیله‌ی برنامه‌نویسانی باتجربه توسعه داده شده‌اند. الگوهای طراحی جزو معماری‌های نرم‌افزاری نیستند و فقط شیوه‌ای صحیح از کدنویسی شی‌گرا را ارائه می‌دهند. بنابراین این الگوها فقط در قلمرو کدنویسی شی‌گرا وارد می‌شوند و مستقل از زبان‌های برنامه‌نویسی هستند.\nالگوهای طراحی اولین بار توسط کریستوف الکساندر (Christopher Alexander) ارائه شدند. کریستوف الکساندر از الگوهای طراحی تحت عنوان راه‌حل‌هایی برای مشکلاتی یاد می‌کرد که به صورت متداول در فرآیند برنامه‌نویسی رخ می‌دهند. مبحث الگوهای طراحی در سال 1994 در کتاب Design Patterns: Elements of Reusable Object-Oriented Software توسط یک گروه چهار نفره ملقب به Gang of Four یا به اختصار GOF مطرح شد. در این کتاب ۲۳ الگوی طراحی کلاسیک نرم‌افزار با زبان‌های شی‌گرا مطرح در آن زمان ++C و Smalltalk مورد بحث قرار گرفته است. چهار نویسنده‌ی این کتاب، اریک گاما (Erich Gamma)، ریچارد هلم (Richard Helm)، رالف جانسون (Ralph Johnson) و جان ولیزدس (John Vlissides) هستند. این کتاب تا تاریخ آوریل ۲۰۰۷، 36 بار تجدید چاپ شده ‌است. طبقه‌بندی الگوهای طراحی از آنجا که الگوهای طراحی فراوانی وجود دارد نیاز به شیوه‌ای جهت سازماندهی آن‌ها وجود دارد. در این کتاب الگوهای طراحی به گونه‌ای طبقه‌بندی شده‌اند که برنامه‌نویسان به راحتی به خانواده‌های الگوهای مربوطه ارجاع نمایند و الگوی مناسب را انتخاب کنند. همچنین این طبقه‌بندی به یادگیری سریع‌تر الگوهای موجود کمک می‌کند. براساس دو ضابطه الگوهای طراحی طبقه‌بندی می شوند: 1- الگوهای طراحی با توجه به کاربردها و اهدافی که به آن منظور ارائه شده اند، به سه دسته عمومی سازنده (Creational)، ساختاری (Structural) و رفتاری (Behavioral) تقسیم‌بندی شده‌اند. الگوهای سازنده به فرآیند ایجاد اشیا مربوط می‌شوند. الگوهای ساختاری به ترکیب کلاس‌ها یا اشیا می‌پردازند. الگوهای رفتاری شیوه‌هایی را که در آن‌ها کلاس‌ها یا اشیا تعامل می‌کنند را مشخص کرده و وظایف را توزیع می‌کنند. 2- الگوهای طراحی با توجه به حوزه (Scope) مورد استفاده نیز به دو دسته الگوهای کلاس و شی تقسیم می‌شوند. الگوهای کلاس به روابط میان کلاس‌ها و کلاس‌های فرعی آن‌ها می‌پردازد. این روابط به گونه‌ای از طریق وراثت مستقر می‌گردند که در زمان کامپایل ایستا باشند. الگوهای شی به روابط اشیا می‌پردازند که می‌تواند در حین اجرا تغییر کنند و پویاتر هستند. تقریبا کلیه‌ی الگوها تا حدی از وراثت استفاده می‌کنند. توجه داشته باشید اغلب الگوها در حوزه شی قرار می‌گیرند. الگوهای کلاس سازنده بخشی از سازنده اشیا را به کلاس‌های فرعی واگذار می‌کنند، در حالی‌که الگوها‌ی شی سازنده آن را با شی دیگری تعویض می‌کنند. الگوهای کلاس ساختاری از وراثت جهت ساختن کلاس‌ها استفاده می‌کنند، در حالی‌که الگوهای شی ساختاری به شرح راه‌هایی جهت نصب اشیا می‌پردازد. الگوهای کلاس رفتاری از وراثت جهت توصیف الگوریتم‌ها و جریان کنترل استفاده می‌کنند، در حالی‌که الگوهای شی رفتاری شرح می‌دهند که چگونه یک گروه از اشیا جهت انجام وظیفه‌ای که هیچ شی منفردی قابل به انجام آن نیست مشارکت می‌کنند.\n","date":"May 29, 2019","img":"","permalink":"/posts/design-patterns/","series":[],"tags":["gof","design patterns"],"title":"الگوهای طراحی (Design Patterns) چیست؟"},{"categories":null,"content":"من آرمان حسن پور هستم. از سال 1390 شروع به برنامه‌نویسی کردم. با زبان‌های برنامه‌نویسی زیادی کار کردم ولی بیشتر از زبان، توانایی حل مسئله برام ارزشمند بوده و هست. بیشتر فعالیتم در حوزه‌های مالی و بانکی بوده و همچنین در مدیریت بانک‌های اطلاعاتی دارای مهارت هستم. علاقه‌مند به یادگیری و کسب مهارت در حوزه‌های جدید فناوری اطلاعات هستم و تلاش می‌کنم که خودمو به روز نگه داشته باشم.\n","date":"Feb 28, 2019","img":"","permalink":"/about/","series":null,"tags":null,"title":"در مورد من"},{"categories":["Oracle","SQL"],"content":"در برخی از سناریوها نیاز به نمایش خروجی چند مقدار به صورت یک مقدار با یک جداکننده مانند کاما داریم. در Oracle می‌توان از تابع LISTAGG برای تبدیل نتایج پرس‌و‌جو به صورت یک مقدار جداشده با کاما استفاده نمود.\nبه طور مثال پرس‌و‌جوی زیر نام قاره‌ها را از جدول regions باز می‌گرداند.\n1SELECT region_name 2FROM regions; نتیجه:\n1REGION_NAME 2------------------------ 3Americas 4Asia 5Middle East and Africa این پرس‌و‌جو چهار سطر مختلف به عنوان نتیجه را باز می‌گرداند. اما اگر بخواهیم این چهار سطر را به صورت یک مقدار جدا شده با کاما نمایش دهیم می‌توانیم آن را به صورت زیر انجام دهیم:\n1SELECT LISTAGG(region_name, \u0026#39;, \u0026#39;) 2FROM regions; نتیجه:\n1LISTAGG(LAST_NAME,\u0026#39;,\u0026#39;) 2----------------------------------------------- 3Europe, Americas, Asia, Middle East and Africa تابع LISTAGG دو مقدار را به عنوان ورودی دریافت می‌نماید. مقدار اول نام ستون و مقدار دوم جدا کننده مورد نظر می‌باشد که در این مثال کاراکتر کاما است. مقدار دوم اختیاری است و اگر داده نشود بدون جدا کننده مقادیر بهم چسبانده می‌شوند.\nامکان استفاده از عبارت DISTINCT در تابع LISTAGG به منظور حذف مقادیر تکراری نیز وجود دارد.\n1SELECT LISTAGG(DISTINCT region_id, \u0026#39;,\u0026#39;) 2FROM countries نتیجه:\n1LISTAGG(DISTINCT region_id, \u0026#39;,\u0026#39;) 2-------------------------------------------- 31,2,3,4 به منظور مرتب سازی نتایج در تابع LISTAGG می‌توان از عبارت WITHIN GROUP (ORDER BY\u0026hellip;) استفاده نمود.\n1SELECT LISTAGG(region_name, \u0026#39;,\u0026#39;) WITHIN GROUP (ORDER BY region_name ASC) 2FROM regions; نتیجه:\n1LISTAGG(region_name, \u0026#39;,\u0026#39;) 2-------------------------------------------- 3Americas,Asia,Europe,Middle East and Africa از تابع LISTAGG می توان در یک پرس‌و‌جو گروه‌بندی شده نیز استفاده نمود.\n1SELECT 2 region_id, 3 LISTAGG(country_id, \u0026#39;, \u0026#39;) WITHIN GROUP (ORDER BY country_id ASC) AS \u0026#34;Countries\u0026#34; 4FROM countries 5GROUP BY region_id 6ORDER BY region_id; نتیجه:\n1REGION_ID\tCountries 2------------------------------------------------ 31\tBE, CH, DE, DK, FR, IT, NL, UK 42\tAR, BR, CA, MX, US 53\tAU, CN, HK, IN, JP, SG 64\tEG, IL, KW, NG, ZM, ZW ","date":"Feb 5, 2019","img":"","permalink":"/posts/oracle-lisagg/","series":[],"tags":["Oracle","LISTAGG","Comma Separated List","SQL"],"title":"نمایش نتایج پرس‌و‌جوها به صورت یک مقدار جداشده با کاما در Oracle"},{"categories":["OOP"],"content":"اعضای داده‌ای خصوصی (private) یک کلاس تنها توسط توابع عضو آن کلاس قابل دسترسی هستند. بنابراین هر کلاس یا تابعی که از توابع عضو یک شی استفاده می‌کند و آن را از خارج از شی فراخوانی می‌کند، تنها می‌تواند توابع عمومی (public) عضو کلاس را به منظور درخواست سرویس‌های کلاس از هر شی خاص فراخوانی نماید.\nدر برنامه‌نویسی شی‌گرا کلاس‌ها از توابع عضو عمومی برای انجام عمل set (یعنی نسب دادن مقدار به) و get (یعنی به دست آوردن مقدار از) برای دسترسی به اعضای داده‌ای خصوصی کلاس استفاده می‌کنند. این نام‎گذاری یک قرارداد متداول است و حتما لازم نیست نام این توابع عضو با set یا get آغاز گردد. توابع set گاهی اوقات تغییردهنده (mutator) نامیده می‌شوند (زیرا آن‌ها مقادیر را تغییر می‌دهند). همچنین توابع get نیز گاهی اوقات دست‌یابنده (accessor) نامیده می‌شوند (زیرا آن‌ها مقادیر را بازیابی می‌نمایند). از طریق توابع set و get می‌توان دسترسی استفاده‌کنندگان از داده‌های خصوصی یک شی را کنترل نمود. این ویژگی اهمیت زیادی در مهندسی نرم‌افزار دارد زیرا اعلان اعضای داده‌ای با سطح دسترسی خصوصی منجر به رعایت اصل پنهان‌سازی داده (encapsulation) می‌شود. اگر توابع set و get را به‌صورت عمومی در اختیار سایرین قرار دهیم استفاده‌کنندگان یک کلاس تنها به صورت غیرمستقیم می‌توانند به داده‌های خصوصی کلاس دستیابی داشته باشند. استفاده‌کنندگان از کلاس فقط می‌توانند داده‌های یک شی را تغییر داده یا آن را بازیابی کند و از نحوه‌ی انجام این کار اطلاعی نداشته باشند. در برخی موارد، ممکن است نحوه‌ی استفاده‌ی داخلی یک کلاس از یک عضو داده‌ای و کاری که بر روی آن انجام می‌دهد، با طرز ارائه‌ی آن به استفاده کننده از آن داده و نحوه‌ی نمایش آن، بسیار متفاوت باشد. توابع set و get به استفاده‌کنندگان کلاس امکان تعامل با شی را می‌دهند، اما داده‌های خصوصی به شکل ایمن در خود شی، به‌صورت پنهان (encapsulated) باقی می‌مانند. به عنوان مثال کلاس Customer یک عضو داده‌ای به نام name داشته و از آن‌ها برای نگهداری نام مشتری هر شی خاصی از کلاس Customer استفاده می‌کند. کلاس مزبور حاوی توابع عضو setName و getName می‌باشد. تابع عضو setName نام مشتری را در یک عضو داده از کلاس Customer ذخیره می‌نماید – تابع عضو getName نام مشتری را در یک عضو داده‌ای از کلاس Customer بازیابی می‌کند.\n1public class Customer { 2 private String name; 3 4 // Getter 5 public String getName() { 6 return name; 7 } 8 9 // Setter 10 public void setName(String newName) { 11 this.name = newName; 12 } 13} شاید فکر کنید که حتی اگر اعضای داده‌ای به صورت خصوصی تعریف شوند، استفاده‌کنندگان همچنان می‌توانند هر زمان که بخواهند به کمک توابع set و get آن‌ها را بخوانند و دستکاری کنند، پس فایده‌ی این مخفی‌کاری چیست؟! جواب این است که توابع set را می‌توان طوری نوشت که داده‌های ورودی به اعضای داده‌ای را کنترل و فیلتر کنند و به هر داده‌ای اجازه‌ی نوشته‌شدن در اعضای داده‌ای را ندهند. همچنین می‌توان به کمک تابع get قالب نمایش داده‌ها را کنترل نمود. برای مثال می‌توانید به کمک تابع set از نوشته شدن مقادیر منفی در عضو داده‌ای \u0026ldquo;نمره\u0026rdquo; جلوگیری نمایید.\n1public class Grade { 2 private int theGrade; 3 4 // Getter 5 public int getGrade() { 6 return theGrade; 7 } 8 9 // Setter 10 public void setAge(int newGrade) { 11\tif(newGrade \u0026gt; 0) 12 this.theGrade = newGrade; 13 } 14} برای مثال دیگر می‌توانید عضو داده‌ای \u0026ldquo;نمره\u0026rdquo; را به صورت کیفی با یک رشته (\u0026ldquo;عالی\u0026rdquo;، \u0026ldquo;خوب\u0026rdquo;، \u0026ldquo;متوسط\u0026rdquo;، \u0026ldquo;قابل قبول\u0026rdquo; و \u0026ldquo;مردود\u0026rdquo;) بازیابی نمایید.\n1public class Grade { 2 private int theGrade; 3 4 // Getter 5 public String getGrade() { 6 if(theGrade \u0026gt;= 80) 7\treturn \u0026#34;Excellent\u0026#34;; 8\telse if(theGrade \u0026gt;= 60 and theGrade \u0026lt; 80) 9\treturn \u0026#34;Good\u0026#34;; 10\telse if(theGrade \u0026gt;= 50 and theGrade \u0026lt; 60) 11\treturn \u0026#34;Average\u0026#34;;\t12\telse if(theGrade \u0026gt;= 40 and theGrade \u0026lt; 50) 13\treturn \u0026#34;Acceptable\u0026#34;; 14\telse if(theGrade \u0026lt; 40) 15\treturn \u0026#34;Fail\u0026#34;; 16\telse\t17\treturn \u0026#34;Invalid grade\u0026#34;; 18 } 19 20 // Setter 21 public void setAge(int newGrade) { 22\tif(newGrade \u0026gt; 0) 23 this.theGrade = newGrade; 24 } 25} هرچند که توابع عضو درون کلاس می‌تواند داده‌های خصوصی را مستقیما مورد دستیابی قرار دهند، اما بهتر است این توابع نیز برای اداره‌ی داده‌های خصوصی کلاس از توابع set و get استفاده کنند. به عنوان مثال تابع displayMessage یک پیغام مبنی بر معرفی مشتری که نام و سن مشتری در آن است را در خروجی نمایش می‌دهد.\n1public class Customer { 2 private String name; 3 private int age; 4 5 // Getter 6 public String getName() { 7 return name; 8 } 9 10 // Setter 11 public void setName(String newName) { 12 this.name = newName; 13 } 14 15 // Getter 16 public int getAge() { 17 return age; 18 } 19 20 // Setter 21 public void setAge(int newAge) { 22 this.age = newAge; 23 } 24 25 public String displayMessage() { 26 return \u0026#34;My name is \u0026#34; + getName() + \u0026#34;. I am \u0026#34; + getAge() + \u0026#34;years old.\u0026#34;; 27 } 28} کنترل مقادیر ورودی به اعضای داده‌ای و قالب‌بندی نمایش آن‌ها می‌تواند تاثیر به‌سزایی در کاهش خطاها و خوانایی برنامه داشته باشد و پایداری و امنیت برنامه را بالا ببرد.\n","date":"Jan 12, 2018","img":"","permalink":"/posts/oop-get-set/","series":[],"tags":["OOP","OOD","Object Oriented","Object"],"title":"مهندسی نرم‌افزار با توابع Get و Set"},{"categories":["General","UML"],"content":"ایجاد مدل و مدل‌سازی برای بررسی دقیق انواع مختلف سیستم‌های نرم‌افزاری در مقیاس کوچک و بزرگ به کار می‌آید. با ساختن مدل این امکان به شما داده می‌شود با ابعاد مختلف پروژه قبل از ساخت آشنا شوید. گاهی در پروژه‌های بزرگ به دلیل پیچیدگی بیش از حد نمی‌شود سیستم را از جنبه‌های مختلف سنجید. بنابراین برای فهم کامل سیستم، یافتن و نمایش ارتباط بین بخش‌های مختلف آن، به مدل‌سازی می‌پردازیم. UML زبانی برای مدل‌سازی یا ایجاد نقشه‌ی تولید نرم‌افزار است.\nدر دهه‌ی 1980، تعداد رو به رشدی از سازمان‌ها برای ایجاد برنامه‌های خود، شروع به استفاده از برنامه نویسی شی‌گرا (OOP) نمودند. بدین ترتیب فقدان یک فرایند تحلیل و طراحی شی‌گرا استاندارد کاملا احساس گردید. بسیاری از متدولوژیست‌ها مثل Booch، Rumbaugh و Jacobsob – شخصا اقدام به تولید فرایندهای مجزا برای پاسخگویی به این نیاز نموده بودند. هر فرایند دارای نشان‌گذاری یا زبان خاص خود بود (به صورت شکل‌های هندسی مصور)، تا نتایج تحلیل و طراحی را به مخاطب بفهماند. تا اوایل دهه‌ی 1990، سازمان‌های مختلف، و حتی بخش‌های موجود در درون همان سازمان‌ها، فرایندها و نشان‌گذاری‌های خاص خود را مورد استفاده قرار می‌دادند. در عین حال، این سازمان‌ها همچنین خواهان استفاده از ابزارهای نرم‌افزاری بودند که فرایند‌های خاص آن‌ها را پشتیبانی نمایند. فروشندگان نرم‌افزار دریافتند که فراهم نمودن ابزار مناسب برای تعداد زیادی از این پیاده‌سازی‌ها کار بسیار دشواری است. بدیهی بود که یک نشان‌گذاری و پیاده‌سازی استاندارد مورد نیاز بود. در سال 1994، James Rumbaugh در شرکت نرم‌افزاری Rational (که بعدها بخشی از IBM شد) به Grady Booch ملحق گردید، و هر دو فعالیت خود را در جهت یکسان‌سازی پیاده‌سازی‌های متداول آغاز نمودند. به زودی Ivar Jacobson نیز به آن‌ها ملحق شد. در سال 1996، این گروه نسخه‌های اولیه UML را به جامعه‌ی مهندسی نرم‌افزار عرضه کردند و خواهان اعلام نتیجه از سوی آن‌ها شدند. در همان زمان، سازمانی به نام گروه مدیریت شی (OMG) فراخوانی برای یک زبان مدل‌سازی مشترک پیشنهاد داده بود. OMG یک سازمان غیر‌انتفاعی بود که استاندارد‌سازی تکنولوژی‌های شی‌گرا با انتشار راهبردها و مشخصه‌هایی از قبیل UML ترویج و ترقی داد. شرکت‌های متعددی از جمله Microsoft، Oracle، IBM، HP، Rational – که پیش از آن نیاز به یک زبان مدل‌سازی مشترک را احساس کرده بودند، در پاسخ به فراخوان OMG، نسخه UML 1.1 را توسعه دادند و آن را به OMG ارسال نمودند. OMG این پیشنهاد را در سال 1997 پذیرفت و مسئولیت نگهداری مستمر و بازنگری در UML را برعهده گرفت. در سال 2003، OMG نسخه UML 1.5 را عرضه کرد. در سال 2005 نیز با انتشار UML نسخه 2 تغییرات اساسی نسبت به نسخه ابتدایی UML ایجاد گردید و این نسخه پایه‌ی بسیاری از کتاب‌ها، ابزارهای مدل‌سازی شد. پیدایش UML همه چیز را تغییر داد و باعث رشد چشم‌گیر مدل‌سازی تصویری و استفاده گسترده از این زبان شد. UML امروزه نقش یک زبان بین‌المللی را در زمینه‌ی تولید نرم‌افزار بر عهده دارد. موسسه‌ی آماری گارتنر در سال ۲۰۰۶ تعداد متخصصان فناوری اطلاعات که از UML استفاده می‌نمودند را ده میلیون نفر برآورد نمود و همچنین تخمین زده است که در سال ۲۰۰۸ هفتاد درصد شرکت‌های تولید نرم‌افزار در سراسر دنیا از UML استفاده کرده‌اند. در حال حاضر UML بیشترین استفاده را در میان رویه‌های تصویری برای مدل‌سازی سیستم‌های شی‌گرا دارد. این زبان رویه‌های متداول نشان‌گذاری را کاملا به صورت یکپارچه در آورده است. آن‌هایی که طراحی سیستم‌های نرم‌افزاری شی‌گرا را انجام می‌دهند از این زبان (به صورت اشکال هندسی) برای مدل کردن سیستم‌های خود استفاده می‌نمایند. یکی از ویژگی‌های جذاب UML انعطاف‌پذیری آن است. UML توسعه‌پذیر است (یعنی توان بهبود یافتن توسط مشخصه‌های جدید را دارد) و مستقل از هر فرایند تحلیل و طراحی شی‌گرای خاص است. باید توجه داشت که UML تنها یک زبان نمادگذاری و مدل‌سازی است و به عنوان یک متدولوژی توسعه نرم‌افزار استفاده نمی‌شود. اما اکنون تمامی توسعه‌دهندگان می‌توانند طراحی‌های خود را با استفاده از یک مجموعه‌ی استاندارد از نشان‌گذاری‌های تصویری بیان نمایند. UML برای استفاده در فرایندهای طراحی شی‌گرا (OOD) طراحی شده است. تعداد فراوانی از چنین فرایندهایی موجود است، که یکی از بهترین‌های آن Rational Unified Process است که توسط شرکت نرم‌افزاری Rational توسعه داده شده است. RUP یک فرایند غنی برای طراحی برنامه‌های قدرتمند صنعتی محسوب می‌گردد. RUP امکان استفاده مؤثرتری از زبان یکپارچه مدل‌سازی (UML) را فراهم می‌سازد. آخرین نسخه UML چهارده گونه نمودار برای مستندسازی مدل‌های سیستم‌ها فراهم می‌آورد، هر مدل یک خصیصه‌ی مجزا از ساختار یا رفتار یک سیستم را مدل می‌کند. هفت نمودار مربوط به ساختار سیستم و هفت نمودار دیگر در ارتباط با رفتار سیستم می‌باشد. نمودارهای ساختاری (Structure Diagrams) نمودار کلاس (Class Diagram) رایج‌ترین نموداری است که در UML استفاده می‌شود. این نمودار یک نمای ایستا (static view) از کلاس‌ها را در یک مدل یا بخشی از یک مدل را نشان می‌دهد. در این نمودار صفات و عملیات کلاس را می‌توان به همراه انواع مختلفی از رابطه‌های بین کلاس‌ها نشان داد. نمودار کلاس نمایی شی‌گرا از یک سیستم را نشان می‌دهد. نمودار شی (Object Diagram) نمودارهای شی از نمودارهای کلاس مشتق می‌شوند، بنابراین نمودارهای شی به نمودارهای کلاس وابسته هستند. این نمودار نمونه‌ای از نمودار کلاس را نشان می‌دهد. مفاهیم اساسی برای نمودارهای کلاس و نمودارهای شی مشابه هستند. نمودارهای شی همچنین دید ایستا از یک سیستم را نشان می‌دهند اما این دید ایستا یک تصویر یا نسخه‌ی فوری از سیستم در یک لحظه خاص است. نمودارهای شیء برای ارائه مجموعه‌ای از اشیاء و روابط آن‌ها به عنوان نمونه استفاده می‌شود. نمودار بسته (Package Diagram) ساختار سلسله مراتبی بسته‌های درون سیستم (که گروه‌هایی از کلاس‌ها هستند) در زمان کامپایل و روابطی که میان بسته‌ها وجود دارد را مدل می‌کند. نمودار ساختار مرکب (Composite Structure Diagram) مشابه نمودار کلاس است با این تفاوت که ساختار داخلی یک شی ترکیبی در زمان اجرا را مدل می‌کند و به طراحان سیستم امکان تجزیه‌ی یک شی ترکیبی به قسمت‌های کوچک‌تر را به صورت سلسله مراتبی می‌دهند. نمودار اجزا (Component Diagram) برای نمایش تصویری از سازمان‌دهی، ترتیب و رابطه‌ی میان اجزا و مولفه‌های سیستم به کار می‌رود. این نمودارها برای ایجاد سیستم‌های قابل اجرا نیز مورد استفاده می‌گیرند. به عبارتی این نمودارها چگونگی تقسیم سیستم به مولفه‌های آن و وابستگی بین مولفه‌های سیستم را توصیف می‌کند. نمودارهای اجزا اغلب برای نشان دادن ساختار سیستم‌های یکپارچه پیچیده، مورد استفاده قرار می‌گیرند. نمودار استقرار (Deployment Diagram) نیازمندی‌های فیزیکی (سخت‌افزاری) زمان اجرای سیستم (مثل کامپیوتر یا کامپیوترهایی که سیستم بر روی آن‌ها مستقر خواهد شد)، نیازمندی‌های حافظه، محیط اجرا و سایر ابزارهایی که سیستم در طی اجرا به آن‌ها نیاز دارد را مدل می‌کند. این نمودار ساختاری، معماری سیستم را در زمان استقرار نرم‌افزار نشان می‌دهد. یک نمودار استقرار کارآمد پارامترهای همچون کارایی، مقیاس‌پذیری، قابلیت نگهداری و قابلیت حمل را کنترل می‌کند. نمودار مشخصات (Profile Diagram) به عنوان مکانیزمی برای گسترش UML استفاده می‌شود که به شما امکان می‌دهد که با افزودن بلوک‌های ساختاری جدید، ایجاد ویژگی‌های جدید و تعیین مفاهیم جدید، UML را گسترش داده و سفارشی کنید تا زبان را برای دامنه مسئله‌ی خاص خود شخصی‌سازی کنید. نمودارهای رفتاری (Behavior Diagrams) نمودار کاربرد (Use Case Diagram) تعاملات میان یک سیستم و موجودیت‌های خارجی (کنش‌گرها) را بر مبنای مورد استفاده آن‌ها مدل می‌کند. نمودار فعالیت (Activity Diagram) فعالیت یک شی را مدل می‌کند و روند کاری (توالی رویدادها) شی در طی اجرای برنامه را نشان می‌دهد. یک نمودار فعالیت، اعمالی را که شی انجام می‌دهد مدل می‌کند و ترتیب انجام این اعمال را از سوی آن مشخص می‌سازد. نمودار حالت (State Machine Diagram) روش‌هایی را که یک شی از طریق آن‌ها وضعیت را تغییر می‌دهند مدل می‌کند. وضعیت یک شی توسط مقادیر تمامی صفات شی در زمان مورد نظر تعیین می‌گردد. هنگامی که یک شی وضعیت را تغییر می‌دهد، ممکن است آن شی در سیستم به شکلی متفاوت رفتار نماید. نمودارهای تعامل (Interaction Diagrams) زیر مجموعه‌ای از نمودارهای رفتاری هستند که بر گردش کنترل و داده‌ها بین چیزهای مختلف در سیستم مدل‌شده تأکید دارند. نمودار توالی (Sequence Diagram) تعاملات میان اشیا یک سیستم را مدل می‌کند اما برخلاف نمودارهای ارتباط، آن‌ها بر زمان وقوع تعامل‌ها تاکید دارند. این نمودارها به نشان دادن ترتیب وقوع تعامل‌ها در زمان اجرای یک عملیات کمک می‌نمایند. نمودار ارتباط (Communication Diagram) تعاملات میان اشیا را با تاکید بر کاری که تعامل‌ها انجام می‌دهند، در یک سیستم مدل می‌کند. نمودار زمان‌بندی (Timing Diagram) فشارها و محدودیت‌های زمانی تحمیل‌شده بر تغییرات میدانی و تعاملات اشیا در یک سیستم را مدل می‌کنند. نمودار چشم‌انداز ارتباط (Interaction Overview Diagram) با ترکیب عناصری از انواع متعدد نمودارهای رفتاری (مثل نمودارهای فعالیت و نمودارهای توالی) چشم‌اندازی از جریان کنترل در سیستم را فراهم می‌نماید. ","date":"Jun 9, 2017","img":"","permalink":"/posts/uml-info/","series":[],"tags":["UML"],"title":"زبان مدل‌سازی یکپارچه (UML) چیست؟"},{"categories":["General","OOP"],"content":"شی‌گرایی یک راه طبیعی تفکر در مورد جهان پیرامون و نوشتن برنامه‌های کامپیوتری است. در دنیای واقعی به هرجا که بنگرید اشیا را مشاهده می‌کنید: اشخاص، حیوانات، گیاهان، اتوموبیل‌ها، هواپیماها، ساختمان‌ها، کامپیوترها و مواردی از این قبیل. انسان‌ها هر روز اشیا را در اطراف خود مشاهده می‌کنند و در مورد آن‌ها به تفکر می‌پردازند.\nاغلب اشیا را به دو دسته تقسیم می‌نماییم: جاندار و بی جان. اشیای جاندار زنده هستند، حرکت می‌کنند و یک سری اعمال انجام می‌دهند. از سوی دیگر، اشیای بی‌جان به خودی خود حرکت نمی‌کنند. اما در هر صورت هر دو نوع شی در یک سری چیزها مشترک هستند. همه‌ی آن‌ها دارای صفاتی می‌باشند (مثلا اندازه، شکل، رنگ و وزن)، و همه‌ی آن‌ها رفتارهایی از خود بروز می‌دهند (مثلا یک توپ قِل می‌خورد، می‌جهد، باد می‌شود و کم باد می‌گردد – یک نوزاد گریه می‌کند، می‌خوابد، می‌خزد، راه می‌رود و چشمان خود را برهم می‌زند – یک اتوموبیل شتاب می‌گیرد، ترمز می‌کند و می‌پیچد). انسان‌ها با مطالعه‌ی صفات اشیا موجود و مشاهده رفتار آن‌ها به کسب اطلاعات در مورد آن‌ها می‌پردازند. اشیای متفاوت می‌توانند دارای صفات مشابه باشند و می‌توانند رفتارهای مشابه از خود بروز دهند. به عنوان مثال، می‌توان میان نوزادان، بزرگسالان و میان انسان‌ها و شامپانزه‌ها شباهت‌هایی یافت. طراحی شی‌گرا (Object-oriented design) اجزای نرم‌افزاری را بر اساس اشیای دنیای واقعی مدل می‌نماید. در حقیقت این روش، مدل‌سازی اشیا توسط صفات، رفتارها و مناسبات مشترک آن‌ها به همان صورتی که ما اشیا دنیای واقعی را توصیف می‌کنیم می‌باشد. طراحی شی‌گرا همچنین ارتباط میان اشیا را مدل می‌کند. دقیقا به همان گونه که افراد به یکدیگر پیغام می‌فرستند (مثلا یک گروه‌بان به یک سرباز دستور می‌دهد)، اشیا نیز از طریق پیغام‌ها با یکدیگر ارتباط برقرار می‌نمایند. مثلا یک شی حساب بانکی ممکن است یک پیغام مبنی بر کاهش پول موجود در خود به یک میزان معین را دریافت نماید. چرا که مشتری آن میزان پول را از حساب خود برداشت نموده است. طراحی شی‌گرا، صفات و اعمال (رفتارها) را در اشیا پنهان (Encapsulate) می‌سازد. اشیا دارای خصوصیت پنهان‌سازی اطلاعات هستند. این بدان معنی است که ممکن است اشیا برقراری ارتباط با دیگری را در میان رابطه‌های خویش تعریف‌شده بدانند، اما آن‌ها اجازه‌ی کسب اطلاع از نحوه پیاده‌سازی سایر اشیا را ندارند. جزییات پیاده‌سازی درون خود اشیا پنهان است. برای نمونه، اگر ما نحوه‌ی استفاده از پدال گاز، پدال ترمز، فرمان و مواردی از این قبیل را بدانیم، می‌توانیم به شکلی کارآمد بدون آن که از جزییات نحوه‌ی عملکرد داخلی سیستم‌های موتور، ترمز و اگزوز آگاهی داشته باشیم، یک اتوموبیل را برانیم. پنهان‌سازی اطلاعات، یک امر حیاتی در مهندسی نرم‌افزار خوب محسوب می‌شود. برنامه‌نویسی با زبان‌هایی که از شی‌گرایی پشتیبانی می‌کنند، برنامه‌نویسی شی‌گرا (Object-oriented programming) نامیده می‌شود. در برنامه‌نویسی شی‌گرا به برنامه‌نویسان امکان پیاده‌سازی یک طراحی شی‌گرا به عنوان یک سیستم نرم‌افزاری کارآمد داده می‌شود. در زبان‌های برنامه‌نویسی شی‌گرا، واحد برنامه‌نویسی کلاس (Class) است که در نهایت اشیا از روی آن نمونه‌سازی (Instantiate) می‌شوند. کلاس‌ها برای اشیا به منزله طرح اولیه برای خانه‌ها است. یک کلاس را می‌توان به عنوان نقشه‌ای برای ساختن یک شی از روی یک کلاس در نظر گرفت. دقیقا همان‌گونه که ما می‌توانیم از روی یک طرح تعداد زیادی خانه بسازیم، می‌توانیم اشیا بسیاری را از روی یک کلاس نمونه‌سازی کنیم. شما نمی‌توانید در طرح یک آشپزخانه اقدام به آشپزی نمایید، بلکه کار آشپزی را در آشپزخانه‌ی موجود در یک خانه انجام می‌دهید. شما نمی‌توانید در طرح یک اتاق خواب بخوابید، بلکه باید در اتاق خواب موجود در یک خانه بخوابید. کلاس‌ها شامل توابعی برای پیاده‌سازی اعمال و داده‌هایی برای پیاده‌سازی صفات می‌باشند. در حقیقت کلاس‌ها دارای مجموعه‌ای از داده‌ها و توابعی هستند که عمل خاصی را بر روی داده‌ها انجام می‌دهند و خدماتی را برای سرویس‌گیرندگان (یعنی سایر کلاس‌ها یا توابعی که از کلاس استفاده می‌نمایند) فراهم می‌نمایند. اجزا داده‌ای یک کلاس تحت عنوان اعضای داده شناخته می‌شوند. برای مثال، یک کلاس حساب بانکی می‌تواند شامل یک شماره حساب و یک موجودی باشد. اجزای تابع یک کلاس تحت عنوان توابع عضو (متد) شناخته می‌شوند. برای مثال، یک کلاس حساب بانکی می‌تواند شامل توابع عضو برای افزایش مبلغ موجودی، کاهش مبلغ موجودی و اعلام موجودی فعلی باشد. کلاس‌ها می‌توانند با سایر کلاس‌ها رابطه داشته باشند. برای مثال، در یک طراحی شی‌گرا از یک بانک، کلاس تحویل‌دار باید با سایر کلاس‌ها مرتبط باشد، کلاس‌هایی از قبیل کلاس \u0026ldquo;مشتری\u0026rdquo;، کلاس \u0026ldquo;حواله‌دهنده\u0026rdquo;، کلاس \u0026ldquo;گاو صندوق\u0026rdquo; و مواردی از این قبیل. این روابط تحت عنوان پیوندها (Associations) شناخته می‌شوند. به عنوان مثالی دیگر در حالتی که اشیا یک کلاس دارای خصیصه‌های یکسان باشند مثل یک کلاس از وسایل نقلیه (اتوموبیل‌ها، کامیون‌ها، واگن‌ها و اسکیت‌ها)، در طراحی شی‌گرا می‌توان از یک کلاس پایه \u0026ldquo;خودرو\u0026rdquo; که شامل ویژگی‌های مشترک بین همه‌ی وسایل نقلیه دارد استفاده نمود. مطمئنا کلاس \u0026ldquo;خودرو\u0026rdquo; ویژگی‌های کلی‌تری از نسبت به هر نوع خاص وسیله نقلیه دارد و همه‌ی وسایل نقلیه می‌توانند از این کلاس به صورت مشترک استفاده نماید یا به اصلاح از آن ارث (Inheritance) ببرند. پیاده‌سازی نرم‌افزار بر اساس کلاس، امکان استفاده‌ی مجدد از کلاس‌ها را در طراحی سیستم‌های نرم‌افزاری بعدی فراهم می‌آورد. مجموعه کلاس‌های مرتبط با هم اغلب به صورت قطعه برنامه‌هایی با قابلیت استفاده مجدد در یک گروه دسته‌بندی می‌شوند. دقیقا همان‌گونه که یک دلال معاملات ملکی می‌گوید سه عامل تاثیر‌گذار بر قیمت املاک \u0026ldquo;مکان، مکان، مکان\u0026rdquo; است، افراد حاضر در جامعه‌ی توسعه‌ی نرم‌افزار هم اغلب می‌گویند سه عامل تاثیر‌گذار بر آینده‌ی توسعه‌ی نرم‌افزار \u0026ldquo;استفاده مجدد، استفاده مجدد، استفاده مجدد\u0026rdquo; است. استفاده مجدد از کلاس‌های موجود در هنگام ساختن کلاس‌ها و برنامه‌های جدید باعث صرفه‌جویی در زمان، هزینه و کار مورد نیاز می‌گردد. همچنین استفاده مجدد به برنامه‌نویسان در جهت ایجاد سیستم‌های قابل اطمینان‌تر و کارآمدتر کمک می‌کند، زیرا کلاس و قطعه برنامه‌های موجود اغلب تست، اشکال‌زدایی و بررسی کارآمدی را به شکلی جامع پشت سر گذاشته اند. با استفاده از فناوری شی، شما می‌توانید بخش اعظم نرم‌افزار جدید مورد نیاز خود را با ترکیب نمودن کلاس‌های موجود بسازید. هر کلاس جدیدی که شما ایجاد می‌نمایید پتانسیل تبدیل شدن به یک سرمایه‌ی نرم‌افزاری با ارزش را دارد، بنابراین شما و سایر برنامه‌نویسان می‌توانید از آن مجددا برای تسریع و بهبود با کیفیت فرایندهای توسعه نرم‌افزار در آینده استفاده کنید.\n","date":"May 12, 2017","img":"","permalink":"/posts/oo-info/","series":[],"tags":["OOP","OOD","Object Oriented","Object"],"title":"شی‌گرایی (Object Oriented) چیست؟"},{"categories":["General"],"content":"چرخه‌ی عمر توسعه‌ی نرم‌افزار (Software Development Life Cycle) مراحلی را شامل می‌شود که نرم‌افزار در طی آن‌ها توسعه می‌یابد یعنی از زمانی که ایده آن مطرح می‌شود تا زمانی که استفاده از آن متوقف می‌گردد.\nاین مراحل شامل: برنامه‌ریزی، تحلیل، طراحی، پیاده‌سازی، تست و اشکال‌زدایی، استقرار و نگهداری است. مدل‌های متعددی برای چرخه‌ی عمر توسعه‌ی نرم‌افزار وجود دارد، که هر کدام اولویت‌ها و ویژگی‌های خود را برای تعیین این موضوع که مهندسان نرم‌افزار چه زمانی و چگونه باید هر یک از این مراحل را انجام دهند دارا می‌باشند. مدل‌های آبشاری (waterfall) این مراحل را یک بار به صورت متوالی انجام می‌دهند، در حالی که مدل‌های تکراری (iterative) ممکن است یک یا چند مرحله را در طی چرخه‌ی عمر یک محصول چندین بار تکرار نمایند. چرخه‌ی عمر توسعه‌ی نرم‌افزار راهی برای اندازه‌گیری و بهبود روند توسعه است. این امر اجازه می‌دهد تا تجزیه و تحلیل دقیق در هر مرحله از روند توسعه انجام شود. این به نوبه‌ی خود به شرکت‌ها کمک می‌کند تا در هر مرحله کارایی خود را به حداکثر برسانند. با افزایش قدرت محاسبات، تقاضای بیشتری برای نرم‌افزار و توسعه‌دهندگان ایجاد می‌شود. شرکت‌ها باید هزینه‌ها را کاهش دهند، نرم‌افزار را سریع‌تر تحویل دهند و نیاز مشتریان خود را برآورده یا از آن‌ها فراتر روند. چرخه‌ی عمر توسعه‌ی نرم‌افزار با شناسایی ناکارآمدی و هزینه‌های بالاتر و رفع صحیح عملکرد آن‌ها به دستیابی به این اهداف کمک می‌کند.\nمراحل چرخه‌ی عمر توسعه‌ی نرم‌افزار برنامه‌ریزی در مرحله‌ی برنامه‌ریزی، مهندسان نرم‌افزار با تجربه، مشکل و دامنه‌ی سیستم‌های موجود را تعریف نموده و اهدافی را برای ساخت سیستم‌های جدید تعیین می‌کنند. مهم‌ترین هدفی که مرحله‌ی برنامه‌ریزی به آن می‌رسد این است که برنامه‌ی زمان‌بندی و هزینه‌ی پروژه را ارائه می‌دهد. عدم برنامه‌ریزی یکی از رایج‌ترین دلایلی است که باعث می‌شود توسعه‌ی نرم‌افزار با شکست مواجه شود. طراحی تضمین کیفیت نرم‌افزار و همچنین شناسایی ریسك‌ها و خطرات بالقوه پروژه نیز در مرحله برنامه‌ریزی انجام می‌گیرد. نتیجه‌ی مطالعات و امکان‌سنجی‌ها موجب بدست آوردن دیدگاه‌های مختلف فنی خواهد بود كه می‌تواند باعث پیاده‌سازی موفقیت‌آمیز پروژه با حداقل ریسک گردد. ###تحلیل تحلیل‌گران سیستم، نیازمندی‌هایی را جمع‌آوری می‌کنند که محدوده‌ی مسئله‌ی مورد نظر را مشخص کند. فرایند جمع‌آوری نیازمندی‌ها یک عمل پایه‌ای در مرحله‌ی تحلیل از چرخه‌ی عمر توسعه‌ی نرم‌افزار است. در مرحله‌ی تحلیل، مهندسان نرم‌افزار یک سند \u0026ldquo;مشخصات نیازمندی‌های نرم‌افزار\u0026rdquo; (Software Requirement Specification) یا به اختصار (SRS) ایجاد می‌کنند. سند SRS شامل تمامی نیازهای نرم‌افزار، سخت‌افزار و شبکه خواهد بود که در نرم‌افزار سفارشی ایجاد‌‌شده مورد نیاز خواهد بود. SRS چگونگی تعامل نرم‌افزار را با سخت‌افزار، رابط‌های خارجی، سرعت کار، زمان پاسخ‌گویی سیستم، قابلیت حمل نرم‌افزار در سیستم‌عامل‌های مختلف، قابلیت اطمینان‌، سرعت بازیابی پس از خرابی‌، امنیت‌، کیفیت‌، محدودیت‌ها و غیره را تعریف می‌کند.\nطراحی مهندسان نرم‌افزار (اگر بخواهیم دقیق‌تر بگوییم، طراحان سیستم) باید سند نیازمندی‌ها را مورد تحلیل قرار داده و سیستم را قبل از پیاده‌سازی طراحی نمایند. در طی این مرحله، طراحان سیستم بر روی درک سند نیازمندی‌ها تمرکز می‌کنند تا الگوی سطح بالایی تولید نمایند که کارهای خواسته‌شده از سیستم را تشریح نماید. خروجی مرحله‌ی طراحی باید نحوه‌ی ساخته‌شدن سیستم را به صورت واضحی مشخص کند تا این نیازمندی‌ها را برآورده سازد. مدل‌های مختلفی به منظور طراحی نرم‌افزارها وجود دارد که طراحان سیستم برای طراحی نرم‌افزارها از آن استفاده می‌کنند. تحلیل و طراحی شی‌گرا (OOAD) یکی از مدل‌هایی است که با استفاده از آن می‌توان سیستم را از دیدگاه شی‌گرایی مورد تحلیل و طراحی قرار داد. در حالت ایده‌آل، یک گروه باید بر روی یک روند کاملا مشخص در حل مسئله و یک روش واحد برای مرتبط ساختن نتایج آن رویکرد به دیگر قسمت‌ها به توافق دست یابد. با توجه به اینکه نحوه‌ی استفاده از تحلیل و طراحی شی‌گرا بسیار متنوع است، امروزه از زبان مدل‌سازی یکپارچه (UML) به منظور مرتبط ساختن نتایج کارها با یکدیگر استفاده می‌شود. طراحان سیستم معمولا براساس نیازمندی‌های مندرج در مستند SRS، یك و یا دو طرح پیشنهادی را جهت تعیین نهایی معماری مورد نیاز انتخاب و در مستند دیگری بنام \u0026ldquo;سند مشخصات طرح\u0026rdquo; (Document Design Specification) یا با اختصار (DDS) ارائه و پیشنهاد می‌نمایند. سند مذکور توسط همه‌ی ذینفعان و براساس معیارهای گوناگون نظیر ارزیابی ریسک، پیمانگی طرح (modularity)، قابلیت استفاده در شرایط مختلف، محدودیت زمانی و بودجه مورد بررسی و ارزیابی قرارگرفته و سرانجام بهترین طراحی جهت تولید نرم‌افزار انتخاب می‌گردد. در طراحی نرم‌افزار تمامی جنبه‌های معماری و همچنین روش‌های ارتباطی و جریان ارسال و دریافت داده‌ها از سامانه‌های دیگر (در صورت وجود آن‌ها) مد نظر قرار می‌گیرد. در معماری پیشنهادی، می‌باید طراحی داخلی همه‌ی مدل‌ها و پیمان‌ها به‌نحوی کاملا واضح و آشکار و با ذکر تمامی جزییات در سند مشخصات طرح (DDS) درج شود. در برخی موارد نیز در این مرحله یک به اصطلاح نمونه‌ی اولیه‌ی محصول (Prototype) تولید می‌شود تا بدین وسیله مناسب‌ترین روش برای توسعه‌‌ی محصول نهایی اتخاذ گردد که خروجی این مرحله مستنداتی شامل لیستی از الگوها و کامپوننت‌های انتخاب‌شده برای توسعه‌ی محصول و در برخی موارد قطعه‌ کدی مربوط به نمونه‌ی اولیه می‌باشد که به عنوان نقطه‌ی شروعی برای پیاده‌سازی نرم‌افزار مورد استفاده قرار می‌گیرد.\nپیاده‌سازی این مرحله شامل ساختن نرم‌افزار می‌شود. در این مرحله از چرخه‌ی حیات توسعه‌ی نرم‌افزار، روند عملیاتی آغاز و نرم‌افزار تولید می‌گردد. مدل‌های مختلف پیاده‌سازی نرم‌افزار وجود دارد که تیم توسعه برای ساخت نرم‌افزار از آن‌ها پیروی می‌کند (مانند برنامه‌نویسی شی‌گرا (OOP)). مهندسین نرم‌افزار تخصصی برای درک بهتر ساخت‌وساز به مستندات تهیه‌شده در مراحل قبل مراجعه می‌کنند. در حالت ایده‌آل، تمام برنامه‌ریزی‌های قبلی که در مراحل قبلی انجام شده باید فرایند ساخت نرم‌افزار واقعی را نسبتا آسان کند. یک پروژه‌ی کوچک ممکن است توسط یک توسعه‌دهنده نوشته شود، در حالی که یک پروژه‌ی بزرگ ممکن است بین چندین تیم تقسیم گردد. در این مرحله از برنامه Source Code Management استفاده کنید. این سیستم‌ها به توسعه‌دهندگان کمک می‌کنند تا تغییرات کد را پیگیری کنند. آن‌ها همچنین به اطمینان از سازگاری بین پروژه‌های مختلف تیمی و اطمینان از تحقق اهداف کمک می‌کنند.\nتست و اشکال‌زدایی تست یک برنامه قبل از در دسترس قرار دادن آن برای کاربران بسیار مهم است. بسیاری از تست‌ها می‌توانند به‌صورت خودکار انجام شوند، مانند تست‌های امنیتی. تست‌های دیگر فقط در یک محیط خاص قابل انجام است؛ ایجاد یک محیط تولید شبیه‌سازی شده برای استقرارهای پیچیده را در نظر بگیرید. تست باید عملکرد صحیح هر فرایند را تضمین کند. قسمت‌های مختلف برنامه نیز باید تست شوند تا به طور یکپارچه با هم کار کنند: آزمون عملکرد، برای کاهش تاخیر در پردازش. مرحله‌ی تست به کاهش تعداد اشکالاتی که کاربران با آن روبرو هستند کمک می‌کند. این امر منجر به رضایت بیشتر کاربر و استفاده بهتر می‌شود.\nاستقرار در مرحله استقرار، برنامه در دسترس کاربران قرار می‌گیرد. بسیاری از شرکت‌ها ترجیح می‌دهند مرحله استقرار را به صورت خودکار انجام دهند. این می‌تواند به سادگی درگاه پرداخت و لینک بارگیری (download) در وب‌سایت شرکت باشد. همچنین ممکن است بارگیری یک برنامه کاربردی در تلفن هوشمند باشد. استقرار نیز می‌تواند پیچیده باشد. به‌روزرسانی یک بانک اطلاعاتی در کل شرکت به یک برنامه تازه توسعه‌یافته یکی از این موارد است. از آنجا که چندین سیستم دیگر توسط بانک اطلاعاتی استفاده می‌شود، ادغام این ارتقا می‌تواند زمان و تلاش بیشتری ببرد. نگهداری و پشتیبانی این مرحله عملکرد نرم‌افزار را از نظر کارآیی بیش‌تر و خطاهای کم‌تر تایید می‌کند. در صورت لزوم، به کاربران در مورد نحوه‌ی بهره‌برداری از نرم‌افزار و نحوه‌ی عملکرد نرم‌افزار آموزش داده می‌شود و یا به آن‌ها کمک می‌شود. این نرم‌افزار به‌موقع، با به‌روزرسانی کد با توجه به تغییراتی که در محیط کاربر نهایی یا تکنولوژی ایجاد می‌شود، حفظ می‌شود. این مرحله ممکن است با اشکالات پنهان و مشکلات ناشناخته در دنیای واقعی روبرو شود. نگهداری و ارتقای نرم‌افزاری برای پوشش، مسائل پوشش داده‌ نشده یا نیازمندی‌های تازه‌ای که ممکن است به وجود آیند مدت خیلی زیادی حتی بیشتر از زمان اولیه‌ی تولید نرم‌افزار زمان بگیرد. این مرحله ممکن است نیاز باشد تا کدهای برنامه‌نویسی تازه‌ای که در طراحی اصلی برنامه نیز دیده نشده اضافه شود تا مسائل و مشکلات دیده‌ نشده حل شوند یا ممکن است کاربر درخواست عملیات اصلی دیگری کند و برنامه‌نویسی‌های تازه‌ای برای برآورده کردن نیازهای جدید انجام گیرد. مرحله‌ی نگهداری شامل مواردی همچون ارائه‌ی نسخه‌ی جدید از نرم‌افزار یا افزودن ویژگی‌های جدید به آن بر اساس نیازهای متغیر کاربران می‌باشد که در طول زمان تغییر کرده و نیازمند بازبینی مجدد می‌باشند و از همین روی می‌توان گفت که چرخه‌ی حیات توسعه‌ی نرم‌افزار نقطه‌ی پایانی نداشته و مرحله‌ی نگهداری نیز به عنوان نقطه‌ی شروع مجدد این چرخه می‌باشد بدین معنی که تمامی مراحل فوق به منظور رفع نیازهای کاربران و ارائه‌ی محصولی باکیفیت می‌باید به طور مداوم تکرار شوند.\n","date":"May 10, 2017","img":"","permalink":"/posts/sdlc-info/","series":[],"tags":["Software","Software Life Cycle","SLC"],"title":"چرخه‌ی عمر توسعه‌ی نرم‌افزار (SDLC) چیست؟"},{"categories":["General"],"content":"اعداد صحیح برای شمارش مناسب هستند، اما گاهی اوقات ما نیاز داریم که اعداد بسیار بزرگ یا اعدادی با جزء کسری را ذخیره کنیم. اعداد اعشاری یا همان اعداد حقیقی برای ارزش‌گذاری عبارت‌هایی كه نیازمند دقت بیشتری هستند، استفاده می‌شوند. برخلاف اعداد صحیح که به آسانی می‌توان آن‌ها را به مقادیر دودویی (binary) تبدیل کرده و در سیستم‌های کامپیوتری استفاده نمود، برای اعداد اعشاری چالش بزرگی پیش رو است تا علاوه بر تبدیل بهینه‌ی اعداد اعشاری به مقادیر دودویی، دامنه‌ی بزرگی از اعداد را هم شامل شود و همچنین دارای دقت و سرعت پردازش بالایی باشد.\nدر علوم کامپیوتر از اصطلاح ممیز شناور (floating point) به عنوان روشی برای نمایش اعداد اعشاری به طوری که محدوده‌ای وسیع از مقادیر را بپذیرند، استفاده می‌شود. اصطلاح \u0026ldquo;ممیز شناور\u0026rdquo; به این واقعیت اشاره دارد که علامت ممیز اعشار می‌تواند \u0026ldquo;شناور\u0026rdquo; باشد. یعنی می‌تواند تعداد متغیری از ارقام، قبل و بعد از علامت ممیز اعشار داشته باشد. در گذشته کامپیوترها‌ی گوناگون روش‌های متفاوتی در پردازش مقادیر ممیز شناور داشتند که این موضوع باعث می‌شد برنامه‌ها بر روی کامپیوترهای مختلف جواب‌های یکسانی را در خروجی نمایش ندهند. به همین منظور در سال 1985 با تلاش گروهی متشکل از ریاضیدانان، دانشمندان علوم کامپیوتر و شرکت‎های تولید سخت‌افزار به سرپرستی William Kahan از دانشگاه کالیفرنیا، استانداردی برای مقادیر ممیز شناور تحت عنوان IEEE754 به سازندگان سخت‌افزارها عرضه شد. با مطرح شدن استاندارد IEEE754 واگرایی شیوه‌های به کار رفته برای نمایش مقادیر ممیز شناور کاهش یافت و بدین ترتیب برنامه‌های نوشته شده برای مقاصد علمی قابل حمل شدند. بسیاری از کامپیوترهای امروزی برای استفاده از مقادیر ممیز شناور از این استاندارد پیروی می‌کنند. طبق این استاندارد روش نمایش و ذخیره‌سازی متغیرهایی از نوع داده ممیز شناور بسیار شبیه به چگونگی نوشتن اعداد با نماد علمی (scientific notation) می‌باشد. نماد علمی یک روش معمول خلاصه‌نویسی در مورد اعداد خیلی بزرگ یا خیلی کوچک می‌باشد. در نگاه اول شاید نماد علمی کمی پیچیده به نظر برسد، اما اگر فهم درستی از نماد علمی داشته باشید، به شما کمک می‌کند تا درک کنید که نوع داده‌ای ممیز شناور چگونه کار می‌کند، و مهم‌تر از آن دارای چه محدودیت‌هایی می‌باشد. نماد علمی در نماد علمی هر عددی می‌تواند، به صورت حاصل‌ضرب دو عدد به شکل: $$ significand * base^{exponent} $$ نوشته ‌شود که در آن base پایه عددی است و نما یا توان (exponent) یک عدد صحیح مثبت یا منفی، و ضریب علمی (significand) یک عدد حقیقی که در مبنای 10 بزرگ‌تر یا مساوی 1 و کوچک‌تر از 10 است می‌باشد. هر چقدر تعداد ارقام در قسمت بعد از اعشار ضریب علمی بیشتر باشد، عدد شما دقیق‌تر می‌باشد. برای مثال در نماد علمی زیر قسمت 1.2 ضریب علمی می‌باشد و عدد 4 توان می‌باشد. این عدد به عدد 12000 ارزیابی می‌گردد. $$ 1.2 * 10^{4} $$ به عنوان مثال جرم زمین را در نظر بگیرید. اگر بخواهیم جرم زمین را در مبنای دهدهی بنویسیم عددی برابر 5973600000000000000000000 کیلوگرم می‌شود. این یک عدد بسیار بزرگ است. همچنین خواندن آن نیز خیلی سخت است (آیا 19 صفر دارد یا 20 صفر؟). اگر جرم زمین را بخواهیم با نماد علمی بنویسیم، خواهیم داشت: $$ 5.9736 * 10^{24} (kg) $$ همانطور که می‌بینید، خواندن نماد علمی آن بسیار ساده‌تر است. همچنین نماد علمی دارای مزیت دیگری است که طی آن می‌توانیم ساده‌تر دو عدد خیلی بزرگ یا دو عدد خیلی کوچک را با هم مقایسه کنیم. این کار تنها با مقایسه توان دو عدد صورت می‌پذیرد. به طوری کلی می‌توان از قواعد زیر برای تبدیل اعداد به نماد علمی استفاده کنید:\nتوان شما از صفر آغاز می شود. ممیز را به سمت چپ ببرید به نحوی که تنها یک رقم غیر از صفر در سمت چپ و قبل از ممیز قرار بگیرد. هر بار که ممیز را یک رقم به سمت چپ منتقل می‌کنید منجر می‌شود تا توان شما 1 واحد افزایش پیدا کند. هر بار که ممیز را یک رقم به سمت راست منتقل می‌کنید منجر می‌شود تا توان شما 1 واحد کاهش پیدا کند. صفرهای قبل از عدد را حذف کنید. صفرهای بعد از عدد را تنها در صورتی حذف کنید که عدد اصلی شما دارای ممیز نباشد. در نماد علمی ترجیح داده می‌شود تا صفرهای بعد از اعشار نگهداری شده و حذف نگردد، چرا که آن صفرها دقت عدد مربوطه را ارائه می‌دهند.\nبرای درک بهتر به مثال‌های زیر توجه کنید: مثال 1 عدد اصلی: 42030 از آخرین رقم در سمت راست شروع کرده و ممیز را 4 رقم به سمت چپ می‌بریم: $$ 4.2030 * 10^{4} $$ هیچ صفری قبل از عدد برای حذف کردن نداریم: $$ 4.2030 * 10^{4} $$ یک صفر در آخرین رقم سمت راست داریم که حذفش می‌کنیم: $$ 4.203 * 10^{4} $$ مثال 2 عدد اصلی: 0.0078900 ممیز را سه رقم به سمت راست می‌بریم تا اولین رقم قبل از ممیز (7) غیر از صفر باشد: $$ 0007.8900 * 10^{3} $$ صفرهای قبل از عدد را از بین می‌بریم: $$ 7.8900 * 10^{3} $$ از آنجا که عدد اصلی ما دارای ممیز می‌باشد، صفرهای سمت راست را حذف نمی‌کنیم: $$ 7.8900 * 10^{3} $$ مثال 3 عدد اصلی: 600.410 ممیز را دو رقم به سمت چپ می‌بریم: $$ 6.00410 * 10^{2} $$ صفر قبل از عدد نداریم که بخواهیم حذفش کنیم: $$ 6.00410 * 10^{2} $$ از آنجا که عدد اصلی ما دارای ممیز می‌باشد، صفرهای سمت راست را حذف نمی‌کنیم: $$ 6.00410 * 10^{2} $$ نماد علمی به صورت دیجیتال یا زمانی که توان به صورت بالانویس مقدور نیست معمولاً با E یا e که معادل «ضربدر ۱۰ به توانِ\u0026hellip;» است نمایش داده می‌شود. به عنوان مثال می‌توان جرم زمین را با نماد علمی به صورت زیر نیز نوشت: $$ 5.9736E24 (kg) $$\nنمایش مقادیر ممیز شناور در IEEE754 استاندارد IEEE754، چند قالب کلی با دقت‌های مختلف از جمله دقت معمولی، دقت مضاعف و دقت‌ مضاعف توسعه‌یافته برای نمایش اعداد ارائه می‌نماید. در این استاندارد، در دقت معمولی از 32 بیت، در دقت مضاعف از 64 بیت و در دقت مضاعف توسعه‌یافته از 128 بیت برای نمایش یک عدد استفاده می‌شود. در روش ارائه‌شده در استاندارد IEEE754 برای نمایش و ذخیره‌سازی انواع ممیز شناور از فرمول زیر استفاده می‌شود: $$ (-1)^{sign} * normalized mantissa * base^{biased exponent} $$ مبنا (base) در نظر گرفته‌شده در استاندارد IEEE754 برابر 2 است. قالب دودویی انواع ممیز شناور نیز به ترتیب زیر است: $$ sign| biased exponent | normalized mantissa $$ علامت (sign) برای اعداد مثبت 0 و برای اعداد منفی 1 می‌باشد و از یک بیت برای نمایش آن استفاده می‌شود. مقدار اعشاری نرمال‌شده (normalized mantissa) بخشی از یک عدد ممیز شناور است که از ارقام معنادار آن تشکیل شده است. بنابراین یک مقدار اعشاری نرمال‌شده عددی است که تنها یک عدد 1 در سمت چپ اعشار دارد. از آنجا همواره عدد سمت اعشار می‌بایست 1 باشد این عدد در فرمت ذخیره‌سازی قرار داده نشده و به صورت پیش‌فرض در نظر گرفته می‌شود. در دقت ساده از 23 بیت، در دقت مضاعف از 52 بیت و در دقت مضاعف توسعه‌یافته از 112 بیت برای نمایش مقدار اعشاری نرمال‌شده استفاده می‌شود. نما یا توان متعادل‌شده (biased exponent) یک عدد صحیح مثبت است که مقدار ثابتی به عنوان bias به آن اضافه شده است تا محدوده توان غیر منفی شود. این مقدار ثابت در دقت معمولی 127، در دقت مضاعف 1023 و در دقت مضاعف توسعه‌یافته 16383 است. همچنین در دقت ساده از 8 بیت، در دقت مضاعف از 11 بیت و در دقت مضاعف توسعه‌یافته از 15 بیت برای نمایش توان متعادل‌شده استفاده می‌شود. به طور مثال ما قصد داریم عدد 5.0- را در به عنوان یک مقدار ممیز شناور معمولی ذخیره کنیم. عدد اصلی در مبنای 2: 0101- برای تبدیل این عدد به یک مقدار اعشاری نرمال‌شده همانند نمایش علمی از آخرین رقم در سمت راست شروع نموده و ممیز را 2 رقم به سمت چپ می‌بریم تا به آخرین 1 برسیم. همچنین به ازای هر رقم یک واحد به توان اضافه می‌کنیم: $$ -01.01 * 10^{2} $$ صفر سمت چپ را نیز حذف می‌کنیم: $$ -1.01 * 10^{2} $$ مقدار ثابت bias را که در دقت معمولی برابر 127 است به توان اضافه می‌کنیم: $$ -1.01 * 10^{2+127} = -1.01 * 10^{129} $$ در عدد به دست آمده مقدار علامت برابر 1، مقدار اعشاری نرمال‌شده برابر 1.01 و توان متعادل‌شده برابر 129 است. از آنجایی که مقدار 1 سمت چپ مقدار اعشاری نرمال‌شده ذخیره نمی‌شود مقدار بیتی عدد -5.0 به صورت زیر است: $$ 0(sign)10000001(exponent)01000000000000000000000(fraction) $$ دقت انواع ممیز شناور از آنجایی که در مقادیر ممیز شناور دقت عدد اعشاری به تعداد بیت قسمت اعشاری محدود شده است در هنگام محاسبات مواردی پیش می‌آید که یک محاسبه مقداری را ایجاد می‌کند که نمی‌تواند دقیقا به وسیله‌ی قالب ممیز شناور ارائه شده توسط IEEE754 نمایش داده شود و سخت‌افزار باید نتیجه را به مقداری که به درستی نمایش داده می‌شود، گرد کند. در استاندارد IEEE754، روش پیش‌فرض برای این کار این است که به نزدیک‌ترین عدد ممکن گرد شود. به عنوان مثال مقدار 1.0 در قالب ممیز شناور به صورت زیر است: $$ 0(sign)01111111(exponent)00000000000000000000000(fraction) $$ که در فرمول IEEE754 به صورت زیر قرار می گیرد: $$ 1.00000000000000000000000(binary) × 2⁰ $$ که برابر عدد زیر در مبنای 2 است: $$ 1.00000000000000000000000 $$ کوچک ترین عددی که می توان به این عدد اضافه یا از این عدد کم کرد برابر با مقدار زیر است: $$ 0.00000000000000000000001(binary) = 0.00000011920928955078(decimal) $$ اگر عددی کوچکتر از 0.00000011920928955078 را جمع یا تفریق کنید، نتیجه تغییر نخواهد کرد زیرا نتیجه به مقدار قبلی گرد می‌شود. وقتی از عدد شناور معمولی استفاده می‌کنید این دقتی است که با عدد 1.0 دارید. در واقع در این مورد مشکل بزرگی نیست زیرا 0.00000011920928955078 برای اکثر برنامه‌ها به اندازه کافی کوچک است. به عنوان مثالی دیگر مقدار 1000000.0 در قالب ممیز شناور به صورت زیر است: $$ 0(sign)10010010(exponent)11101000010010000000000(fraction) $$ که در فرمول IEEE754 به صورت زیر قرار می‌گیرد: $$ 1.11101000010010000000000(binary) × 2¹⁹ $$ که برابر عدد 11110100001001000000.0000 در مبنای 2 است: $$ 11110100001001000000.0000 $$ کوچک‌ترین عددی که می‌توان به این عدد اضافه یا از این عدد کم کرد برابر با مقدار زیر است: $$ 0.0001(binary) = 0.0625(decimal) $$ در این مورد، دقت در مقایسه با زمانی که عدد 1.0 است بسیار کمتر است که این می‌تواند مشکل‌ساز باشد. به عنوان مثال اگر از نوع ممیز شناور با دقت معمولی برای نمایش زمان (ثانیه) از زمان شروع یک برنامه کاربردی استفاده شده باشد و برنامه هر 0.05 ثانیه زمان را شمارش کند، پس از 1000000.0 (یا قبل از آن)، زمان از حرکت باز می‌ایستد!\n","date":"Feb 8, 2017","img":"","permalink":"/posts/float-info/","series":[],"tags":["Float","Floating-point","Scientific Notation","IEEE754"],"title":"ممیز شناور (Floating Point) چیست؟"},{"categories":["General"],"content":"UUID اختصار عبارت Universally Unique Identifier به معنای شناسه منحصر به فرد جهانی می‌باشد. به‌جای این اصطلاح از GUID که اختصار عبارت Globally Unique Identifier به معنای شناسه منحصر به فرد عمومی نیز استفاده می‌شود. GUID یک اصطلاح صنعتی است که توسط شرکت مایکروسافت برای ارائه یک شماره مرجع که در هر زمینه‌ای منحصر به فرد است، تعریف شده است در حالی که در محیط آکادمیک و در استانداردها از اصطلاح UUID استفاده شده است. هر دو اصطلاح به یک موضوع اشاره دارند و تفاوتی در استفاده ندارند.\nUUIDها یک عدد صحیح 128 بیتی هستند که اگر طبق روش‌های استاندارد تولید شوند، بدون آنکه به یک نهاد ثبت‌کننده مرکزی یا هماهنگی با سایر تولیدکننده‌های UUID برای تایید یکتایی نیاز داشته باشند، عملا یکتا خواهند بود. اگرچه احتمال اینکه یک UUID تکراری باشد، صفر نیست، اما آنقدر به صفر نزدیک است که می‌توان از آن چشم‌پوشی نمود. بنابراین هر کسی می‌تواند یک UUID ایجاد کند و از آن برای شناسایی موجودیتی استفاده کند و اطمینان داشته باشد که شناسه‌ای که تولید کرده ‌است با شناسه‌هایی که قبلا تولید شده یا بعدا تولید خواهد شد، تداخلی ندارد. اطلاعاتی که بوسیله UUIDها توسط موجودیت‌های مستقل برچسب‌گذاری شده‌اند می‌توانند بعدا با یکدیگر ادغام شده و در یک بانک اطلاعاتی قرار گیرند، بدون آنکه نیاز به از بردن تداخل‌های بین شناسه‌ها شود. UUIDها توسط Open Software Foundation (OSF) که بخشی از Distributed Computing Environment (DCE) است استانداردسازی شده‌اند. UUIDها در سال 1996 به عنوان بخشی از استاندارد ISO/IEC 11578:1996 \u0026ldquo;Information technology – Open Systems Interconnection – Remote Procedure Call (RPC)” و همچنین در سال 2005 نیز در استاندارد ITU-T Rec. X.667 | ISO/IEC 9834-8:2005 مستندسازی شده‌اند. همچنین Internet Engineering Task Force (IETF) با انتشار Standards-Track RFC 4122 که از نظر فنی با استاندارد ITU-T Rec. X.667 | ISO/IEC 9834-8 برابر است مستندات مربوط به UUIDها منتشر کرده است. در شیوه متعارف نمایش متنی، شانزده بایت یک شناسه GUID توسط 32 رقم هگزادسیمال (مبنای 16) که در 5 گروه که توسط خط فاصله از یکدیگر جدا شده‌اند در قالب 12-4-4-4-8 که در مجموع 36 کاراکتر (32 کاراکتر الفبایی و چهار خط فاصله) را تشکیل می‌دهد، نشان داده می‌شوند.\n1xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx نمونه 1\n1123E4567-E89B-12D3-A456-426614174000 نمونه 2\n1B4D0257C-BE19-4800-BA11-A09AC2561898 UUIDها دارای سه نوع و پنج نسخه می‌باشند. چهار بیت از رقمی که با M نشان داده شده ‌است، نسخه UUID و رقمی که با N نشان داده شده ‌است، نوع UUID را مشخص می‌کند.\n1xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx در نمونه 1، مقدار M برابر یک و مقدار N برابر a است، به این معنی است که نوع UUID از نوع یک، و نسخه آن نیز ۱ می‌باشد. در نمونه 2، مقدار M برابر 4 و مقدار N برابر b است، به این معنی که نوع UUID از نوع یک و نسخه آن 4 می‌باشد.\nانواع UUID نوع صفر - N = 0..7 برای سازگاری با سیستم قدیمی قالب UUID 1.5 سامانه محاسبات شبکه‌ایApollo در سال 1988 تعریف شده ‌است. در این قالب، 6 بایت اول زمان با طول 48 بیت است (تعداد واحدهای 4 میلی ثانیه از 1 ژانویه 1980 UTC). دو بایت بعدی رزرو شده است و بایت بعدی نوع آدرس‌دهی در شبکه Apollo است. هفت بایت آخر نیز یک شناسه میزبان 56 بیتی است که با توجه به نوع آدرس‌دهی تعیین می‌شود.\nنوع یک - N = 8..b این نوع در استاندارد RFC 4122/DCE 1.1 UUIDs ارجاع داده شده است و نوع رایج UUID می‌باشد.\nنوع دو - N = c..d این نوع که با عنوان GUID توسط شرکت مایکروسافت مطرح شده است اولین بار توسط این شرکت در سیستم عامل ویندوز مورد استفاده قرار گرفته است. نوع یک و دو در نمایش رشته‌ای مشابه هم هستند و تنها در بیت مربوط به نوع باهم متفاوت هستند اما در نمایش دودویی در روش نگهداری نیز باهم متفاوت هستند. در نوع یک از ترتیب بایت big-endian استفاده می‌شود در حالی که در نوع دو از ترتیب بایت little-endian استفاده شده است.\nنوع رزرو شده - N = e..f این بازه برای استفاده در آینده رزرو شده است.\nنسخه های UUID نسخه یک – زمان و آدرس MAC در این نسخه از زمان سیستم و آدرس MAC کارت شبکه که منحصر به فرد برای تولید UUID استفاده می‌شود. با داشتن UUID نسخه 1 با استخراج مقدار timestamp می‌توانید به این موضوع پی ببرید که این UUID چه زمانی تولید شده است. قالب متعارف UUIDهای مبتنی بر زمان به صورت زیر است:\nنام اندازه (بایت) طول (هگزادسیمال) محتوا time_low 4 8 عدد صحیحی که ۳۲ بیت پایینی زمان است time_mid 2 4 عدد صحیحی که ۱۶ بیت میانی زمان است time_hi_and_version 2 4 ۴ بیت پرارزش، نسخه را مشخص کرده و ۱۲ بیت دیگر ۱۲ بیت بالایی زمان است clock_seq_hi_and_res clock_seq_low 2 4 بیت‌های ۱ تا ۳ پرارزش نوع UUID و۱۳ تا ۱۵ بیت باقی مانده توالی ساعت است (clock sequence) node 6 12 شناسه گره ۴۸ بیتی نسخه دو - زمان و آدرس MAC و نسخه امنیتی DCE این نسخه به صورت خاص در استاندارد RFC 4122 تعریف نشده است و عمومیت ندارد. مشابه نسخه 1 است با این تفاوت که 4 بایت ابتدایی از timestamp با POSIX UID کاربر و بایت پر ‌ارزش توالی ساعت با POSIX UID دامنه جایگزین شده است.\nنسخه سه – MD5 hash و Namespace در این نسخه برای تولید UUID از Hash نمودن نام و شناسه Namespace توسط الگوریتم MD5 استفاده می‌شود. شناسه فضای نام می‌بایست خود منحصر به فرد باشد. مانند آدرس‌ها، نام‌های دامنه، شناسه موجودیت‌ها و نام‌های متمایز X.500 می‌توانند به عنوان فضای نام انتخاب شوند.\nنسخه چهار – تصادفی در این نسخه از اعداد تصادفی برای تولید UUID استفاده می‌شود. از 128 بیت، 6 بیت برای نوع و نسخه UUID رزرو شده و مابقی 122 بیت به صورت تصادفی مقدار می‌گیرند که 2 به توان 122 احتمال را شامل می‌شود. از روش های متفاوتی برای تولید اعداد تصادفی در این نسخه استفاده می‌شود و استاندارد مشخصی در این زمینه وجود ندارد.\nنسخه پنج - SHA-1 hash و Namespace مشابه نسخه 3 است با این تفاوت که از الگوریتم SHA-1 به جای MD5 برای Hash نمودن استفاده می‌شود.\nUUID خالی یا Nil UUID برای UUID یک مقدار خالی یا تهی در نظر گرفته شده است که مقدار آن 00000000-0000-0000-0000-000000000000 می‌باشد.\nصحت یکتایی UUID برخورد (Collisions) هنگامی رخ می‌دهد که یک UUID بیش از یک بار ایجاد شده و به مراجع مختلف اختصاص داده شود. در مورد UUIDهای نسخه 1 و نسخه 2 که با استفاده از آدرس‌های MAC کارت‌های شبکه که منحصر به فرد هستند ساخته شده‌اند، فقط زمانی که پیاده‌سازی استانداردها متفاوت باشد یا ایراداتی در آن وجود داشته باشد احتمال برخورد وجود دارد.\nبرخلاف نسخه 1 و نسخه 2 UUID که از آدرس‌های MAC منحصر به فرد کارت‌های شبکه استفاده می‌کنند، در نسخه 1 و 2 UUID تصادفی و نسخه 3 و 5 که مبتنی بر Hash هستند و نسخه 4 UUID تصادفی، احتمال برخورد وجود دارد. البته با احتمال بسیار کمی که به طور معمول قابل چشم پوشی است. این احتمال را می‌توان دقیقا بر اساس تجزیه و تحلیل پارادوکس تولد محاسبه کرد.\nبه عنوان مثال، تعداد UUIDهای نسخه 4 تصادفی که باید ایجاد شوند تا به احتمال 50٪ حداقل یک برخورد باید تولید شود برابر 2.71 کوئین تیلیون است. این عدد معادل تولید 1 میلیارد UUID در ثانیه برای حدود 85 سال است. فایلی که حاوی این تعداد UUID باشد، با 16 بایت در هر UUID، تقریباً 45 اگزا بایت خواهد بود. احتمال یافتن نسخه تکراری در نسخه 103 تریلیون نسخه 4 UUID یک در میلیارد است.\n","date":"Feb 5, 2017","img":"","permalink":"/posts/uuid-guid-info/","series":[],"tags":["UUID","GUID"],"title":"شناسه منحصر به فرد جهانی (UUID) چیست؟"},{"categories":["General"],"content":"IP اختصار عبارت Internet Protocol است که مدل فنی ارسال و دریافت بسته‌ها در اینترنت را به همراه آدرس فرستنده و گیرنده در شبکه‌ی اینترنت یا هر شبکه‌ی کامپیوتری مشخص می‌کند. در حال حاضر دو نسخه برای IP وجود دارد که شامل IPv4 و IPv6 است.\nIPv6 که Internet Protocol Next Generation نیز خوانده می‌شود، جدیدترین پروتکل اینترنت برای اختصاص آدرس IP است که برای تکمیل و در نهایت جایگزین شدن IPV4 در نظر گرفته شده است. در حال حاضر تا زمان مقتضی شاهد استفاده از هر دو پروتکل به‌صورت هم‌زمان خواهیم بود تا اینکه در نهایت IPv6 به‌صورت کامل جای این پروتکل را بگیرد. IPv6 به این علت طراحی شده است تا علاوه بر داشتن آدرس‌های بیشتر برای اتصال دستگاه‌های بیشتر در مقایسه با IPv4، ظرفیت انتقال اطلاعات در شبکه اینترنت یا همان ترافیک را افزایش دهد. IPv4 یک آدرس اینترنتی 32 بیتی است که به‌صورت اعداد ده‌دهی (دستگاه اعداد مبنای ۱0) در قالب یک رشته نمایش داده می‌شود. یک آدرس اینترنتی مبتنی بر IPv4 به‌صورت چهار دسته (Octet) 8 بیتی نوشته می‌شود که توسط یک نقطه از هم جدا می‌شوند. هر یک از چهار دسته عدد سه‌تایی می‌تواند مقادیر صفر تا 255 را داشته باشد. پس برای هر بخش می توان 256 رقم (2 به توان 8) را در نظر گرفت که با این حساب 2 به توان 32 یا 4294967296 رقم خواهیم داشت. برای مثال آدرس زیر یک آدرس اینترنتی مبتنی بر IPv4 است.\n1172.16.110.1 IPv6 یک آدرس اینترنتی 128 بیتی است که به‌صورت اعداد هگزادسیمال استاندارد (دستگاه اعداد مبنای 16) در قالب یک رشته نمایش داده می‌شود. یک آدرس اینترنتی مبتنی بر IPv6 به‌صورت هشت دسته (Octet) 16 بیتی نوشته می‌شود که توسط یک کالِن از هم جدا می‌شوند. هر یک از هشت دسته 8 بیتی می‌تواند مقادیر 0000 تا FFFF را داشته باشد. پس برای هر بخش می‌توان 65,536 رقم (2 به توان 16) را در نظر گرفت که با این حساب 2 به توان 128 یا 340,282,366,920,938,463,463,374,607,431,768,211,456 عدد خواهیم داشت که حدود 7,922,816,251,426,433,759,354 برابر بیشتر از IPv4 می‌باشد. برای مثال آدرس زیر یک آدرس اینترنتی مبتنی بر IPv6 است.\n165b3:b834:45a3:0000:0000:762e:0270:5224 در IPv6 بخش‌هایی که تمام رقم‌های آن صفر می‌باشند را می‌توان حذف نمود و به جای آن‌ها از کاراکتر : استفاده کرد. به عنوان مثال آدرس‌های زیر مشابه هم هستند:\n12001:cdba:0000:0000:0000:0000:3257:9652 2 32001:cdba:0:0:0:0:3257:9652 4 52001:cdba::3257:9652 ","date":"Jan 3, 2017","img":"","permalink":"/posts/ip-info/","series":[],"tags":["IP"],"title":"آدرس IP چیست؟"},{"categories":["General"],"content":"برنامه‌نویس‌های موفق عادات مشترکی دارند که آن ها را از جهات مختلف در یک گروه قرار می‌دهد. اگر شما هم یک برنامه‌نویس هستید شاید شما هم بسیاری از این عادات را داشته باشید.\nیک برنامه‌نویس موفق هیچ وقت سر وقت در محل کارش پیدایش نمی‌شود! همیشه عجله دارد ولی مرد یک دو سه نیست. معنای نیمه شب‌ها برای یک برنامه‌نویس موفق با نیمه شب انسان‌های عادی تفاوت دارد. نیمه شب برای یک برنامه‌نویس یعنی ۱۰ صبح برای یک انسان عادی! یک برنامه‌نویس همیشه تعدادی لغات تخصصی در آستین دارد که می‌تواند با سر هم کردن آن‌ها، دیگران را گیج کند. برای یک برنامه‌نویس هیچ راه‌حلی بالاتر از Restart کردن وجود ندارد. برای یک برنامه‌نویس موفق یا نام بیل گیتس مقدس است و معبدش ویندوز می‌باشد یا خدایش لینوس توروالدز است و معبدش لینوکس. یک برنامه‌نویس موفق فقط و فقط با لپ‌تاپ خود عشق بازی می‌کند. یک برنامه‌نویس موفق می‌داند طعم قهوه وقتی سیگاری بر گوشه‌ی لب خود دارد چه مفهومی دارد. یک برنامه‌نویس موفق اکثراً قهوه و چایی ولرم می‌نوشد. برنامه‌نویسی موفق است که کلمه‌ی نظم را خودش معنا کرده باشد. اتاق و محل کار یک برنامه‌نویس موفق هیچ‌گاه مرتب نیست بلکه تابع معنای نظم زندگی‌اش است. یک برنامه‌نویس موفق می‌داند که فست‌فود تنها غذای جسم اوست و یک موزیک متالیکا بخصوص مال ۱۹۹۲ غذای روحش. یک برنامه‌نویس موفق به ندرت عصبانی می‌شود ولی وای به آن لحظه که عصبانی شود\u0026hellip; یک برنامه‌نویس موفق دختران زیادی را در زندگی خود داشته است ولی فقط یکی از آن‌ها بوده که او را می‌فهمیده ولی او اکنون نیست. یک برنامه‌نویس موفق در هر لحظه می‌تواند کل کل کند و معنای باخت را هرگز نچشد. یک برنامه‌نویس موفق هیچگاه خواب زن‌های برهنه را نمی‌بیند. یک برنامه‌نویس موفق همیشه مشکوک است ولی خود را آرام نشان می‌دهد. یک برنامه‌نویس موفق همیشه با عرفان و فلسفه لاس می‌زند ولی همیشه هم فاصله‌اش را با آن حفظ می‌کند. یک برنامه‌نویس موفق اوج زندگیش را در سن ۱۸ تا ۲۶ سالگی می‌داند. برنامه‌نویس موفق همه‌ی بچه‌ها را دوست دارد البته تا وقتی که گریه نکنند. فقط یک برنامه‌نویس موفق است که معنای ۵۴ ساعت بیداری و کار مداوم را درک می‌کند. یک برنامه‌نویس موفق همیشه تنهاست. زندگی او در برنامه‌هایش خلاصه شده است. ۴۰ سالگی زمان بازنشستگی یک برنامه‌نویس موفق است، یعنی زمانی که به خود می‌گوید: می‌خواهم زن بگیرم! مردم برای یک برنامه‌نویس موفق نقش ابلهانی را دارند که فقط می‌توانند سفارش پروژه‌ای را بدهند که خودشان هم دقیقا نمی‌دانند هدف‌شان از سفارش آن پروژه چیست؟ یک برنامه‌نویس موفق زود از دختران خسته می‌شود، گاهی در تنهایی فقط به آنها فکر می‌کند. کابوس یک برنامه‌نویس موفق، شرکت در جلسه‌ای با حضور کاربران عوام است و بلاهای طبیعیش هم بهم ریختن دسکتاپش است. اینترنت را قطع کنید تا ببینید یک برنامه‌نویس موفق چه رفتارهای ناهنجاری انجام می‌دهد. فقط یک برنامه‌نویس موفق است که می‌تواند بدترین دعوا را با مدیر عامل داشته باشد ولی ککش هم نگزد. یک برنامه‌نویس موفق OOP را هضم کرده و با SOA رقص تانگو می‌کند. خب! کدومتون یک برنامه‌نویس موفق هستید؟؟؟ :)\n","date":"Dec 11, 2015","img":"","permalink":"/posts/successful-programmer/","series":[],"tags":["Programmer"],"title":"چگونه یک برنامه‌نویس موفق شویم؟"},{"categories":["General","SQL"],"content":"به منظور استفاده از جداول نمونه یکسان در مطالب این وبلاگ تصمیم گرفتم در یک مطلب جداگانه اسکریپت‌های مربوط به ایجاد جداول و ثبت داده‌های پیش فرض آن را برای هر نوع بانک اطلاعاتی قرار دهم. در این مطلب اسکریپت مربوط به بانک اطلاعاتی Oracle قرار داده شده است.\nجدول regions 1CREATE TABLE regions ( 2 region_id NUMBER(10) PRIMARY KEY, 3 region_name VARCHAR2(25) DEFAULT NULL 4); 5 6INSERT INTO regions(region_id,region_name) VALUES (1,\u0026#39;Europe\u0026#39;); 7INSERT INTO regions(region_id,region_name) VALUES (2,\u0026#39;Americas\u0026#39;); 8INSERT INTO regions(region_id,region_name) VALUES (3,\u0026#39;Asia\u0026#39;); 9INSERT INTO regions(region_id,region_name) VALUES (4,\u0026#39;Middle East and Africa\u0026#39;); جدول countries 1CREATE TABLE countries ( 2\tcountry_id CHAR(2) PRIMARY KEY, 3\tcountry_name VARCHAR2(40) DEFAULT NULL, 4\tregion_id NUMBER(10) NOT NULL, 5\tFOREIGN KEY (region_id) REFERENCES regions (region_id) ON DELETE CASCADE 6); 7 8INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;AU\u0026#39;,\u0026#39;Australia\u0026#39;,3); 9INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;AR\u0026#39;,\u0026#39;Argentina\u0026#39;,2); 10INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;BE\u0026#39;,\u0026#39;Belgium\u0026#39;,1); 11INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;BR\u0026#39;,\u0026#39;Brazil\u0026#39;,2); 12INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;CA\u0026#39;,\u0026#39;Canada\u0026#39;,2); 13INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;CH\u0026#39;,\u0026#39;Switzerland\u0026#39;,1); 14INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;CN\u0026#39;,\u0026#39;China\u0026#39;,3); 15INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;DE\u0026#39;,\u0026#39;Germany\u0026#39;,1); 16INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;DK\u0026#39;,\u0026#39;Denmark\u0026#39;,1); 17INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;EG\u0026#39;,\u0026#39;Egypt\u0026#39;,4); 18INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;FR\u0026#39;,\u0026#39;France\u0026#39;,1); 19INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;HK\u0026#39;,\u0026#39;HongKong\u0026#39;,3); 20INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;IL\u0026#39;,\u0026#39;Israel\u0026#39;,4); 21INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;IN\u0026#39;,\u0026#39;India\u0026#39;,3); 22INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;IT\u0026#39;,\u0026#39;Italy\u0026#39;,1); 23INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;JP\u0026#39;,\u0026#39;Japan\u0026#39;,3); 24INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;KW\u0026#39;,\u0026#39;Kuwait\u0026#39;,4); 25INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;MX\u0026#39;,\u0026#39;Mexico\u0026#39;,2); 26INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;NG\u0026#39;,\u0026#39;Nigeria\u0026#39;,4); 27INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;NL\u0026#39;,\u0026#39;Netherlands\u0026#39;,1); 28INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;SG\u0026#39;,\u0026#39;Singapore\u0026#39;,3); 29INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;UK\u0026#39;,\u0026#39;United Kingdom\u0026#39;,1); 30INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;US\u0026#39;,\u0026#39;United States of America\u0026#39;,2); 31INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;ZM\u0026#39;,\u0026#39;Zambia\u0026#39;,4); 32INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;ZW\u0026#39;,\u0026#39;Zimbabwe\u0026#39;,4); ","date":"Jan 8, 2014","img":"","permalink":"/posts/oracle-sample-tables/","series":[],"tags":["Oracle","SQL"],"title":"نمونه جدول‌های Oracle"},{"categories":["General"],"content":"در این مطلب کتاب‌های معتبر مرتبط با برنامه‌نویسی و بانک‌های اطلاعاتی را برای دانلود قرار دادم. این مطلب به مرور به‌روزرسانی می‌شود و کتاب‌های بیشتری به آن اضافه می‌شود.\nJava How to Program, 11/e, Early Objects by Paul Deitel, Harvey Deitel Pearson Head First Java, A Brain-Friendly Guide, 3rd Edition by Kathy Sierra, Bert Bates, Trisha Gee - O\u0026rsquo;Reilly Media Design Patterns: Elements of Reusable Object-Oriented Software, by Erich Gamma, John Vlissides, Ralph Johnson, Richard Helm ","date":"Jan 6, 2014","img":"","permalink":"/posts/books/","series":[],"tags":[],"title":"کتابخانه"},{"categories":["General"],"content":"به منظور ترجمه یکسان کلمات انگلیسی در مطالب این وبلاگ تصمیم گرفتم در یک مطلب جداگانه ترجمه کلمات (یا معادل فارسی مورد استفاده) را قرار دهم.\nargument - آرگومان assembly - اسمبلی binary - باینری call specification - مشخصات فراخوانی checklist - چک لیست class - کلاس clause - عبارت code - کد collision - برخورد، تصادم comma - کاما compile - کامپایل compiler - کامپایلر database - بانک اطلاعاتی design pattern - الگو طراحی directory - دایرکتوری file - فایل function - تابع load - بارگذاری method - متد namespace - فضای نام object - شی query - پرس‌و‌جو reusable - قابل استفاده مجدد schema - اسکیما scope - حوزه stored procedure - روال‌ ذخیره‌شده trustworthy - اعتماد\n","date":"Jan 5, 2014","img":"","permalink":"/posts/dict/","series":[],"tags":[],"title":"واژه نامه"},{"categories":null,"content":"","date":"Jan 1, 0001","img":"","permalink":"/contact/","series":null,"tags":null,"title":"تماس با من"}]