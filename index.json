[{"categories":["Shetab"],"content":"سامانه‌ی شتاب به عنوان تنها سوئیچ ملی بین بانکی کشور، سیستمی مبتنی بر کارت‌ بوده و وظیفه تبادل تراکنش‌های بین بانکی و اعمال مقررات بانک مرکزی به عنوان مقام ناظر را بر عهده دارد و سطح گستردگی این سامانه شامل کلیه بانک‌های کشور است که با اتصال به چند سوئیچ برون‌مرزی، کل تراکنش‌های کارتی کشور را پوشش می‌دهد.\nسامانه‌ی شتاب جهت تبادل پیام‌ها و تراکنش‌های مالی از استاندارد ISO8583 استفاده کرده و قابلیت پشتیبانی از سه ویرایش این استاندارد که در سال‌های 1987، 1993 و 2003 ارائه گردیده است را دارد. بانک مرکزی در سال 1392 با ارائه نسخه 7 شتاب بانک‌ها را ملزم به استفاده از ویرایش 2003 این استاندارد کرده است. شتاب وظیفه انتقال امن اطلاعات و داده‌های مربوط به تراکنش‌های ‌مالی و غیرمالی به بانک‌های صادرکننده و یا پذیرنده را دارد. این مرکز با استفاده از سخت افزارها، نرم افزارها و شبکه‌ی ارتباطی خود، پیام‌ها و داده‌های اخذ شده از اعضا را پذیرش کرده، آن‌ها را ثبت، مسیریابی و به بانک‌های صادرکننده یا پذیرنده ارسال می‌نماید. نتیجه این اقدامات دریافت خدمات مبتنی بر کارت توسط دارندگان کارت بانک‌ها از تجهیزات سایر بانک‌ها می‌باشد. شتاب برای نظارت بیشتر بر شبکه‌ی بانکی با ارتباط با مرکز کنترل و نظارت اعتباری (مکنا) کلیه سوابق مشتریان و قوانین بالا دستی را کنترل و بر تراکنش‌های تبادلی در این شبکه نظارت دارد.\n","date":"Jun 3, 2020","img":"","permalink":"/posts/shetab-info/","series":[],"tags":["شتاب","Shetab"],"title":"سامانه شتاب"},{"categories":["SQLServer"],"content":"یکی از موارد پُرکاربرد در مهندسی معکوس نرم‌افزارهای دارای بانک اطلاعاتی جستجوی یک مقدار در کل جدول‌های یک بانک اطلاعاتی است.\nبه این منظور می‌توان از کد زیر استفاده نمود:\n1DECLARE @SearchStr nvarchar(100) 2SET @SearchStr = \u0026#39;## YOUR STRING HERE ##\u0026#39; 3 4CREATE TABLE #Results (ColumnName nvarchar(370), ColumnValue nvarchar(3630)) 5 6SET NOCOUNT ON 7 8DECLARE @TableName nvarchar(256), 9\t@ColumnName nvarchar(128), 10\t@SearchStr2 nvarchar(110) 11 12SET @TableName = \u0026#39;\u0026#39; 13 14SET @SearchStr2 = QUOTENAME(\u0026#39;%\u0026#39; + @SearchStr + \u0026#39;%\u0026#39;,\u0026#39;\u0026#39;\u0026#39;\u0026#39;) 15 16WHILE @TableName IS NOT NULL 17BEGIN 18 SET @ColumnName = \u0026#39;\u0026#39; 19 SET @TableName = 20 ( 21 SELECT MIN(QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME)) 22 FROM INFORMATION_SCHEMA.TABLES 23 WHERE TABLE_TYPE = \u0026#39;BASE TABLE\u0026#39; 24 AND QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME) \u0026gt; @TableName 25 AND OBJECTPROPERTY( 26 OBJECT_ID( 27 QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME) 28 ), \u0026#39;IsMSShipped\u0026#39; 29 ) = 0 30 ) 31 32 WHILE (@TableName IS NOT NULL) AND (@ColumnName IS NOT NULL) 33 BEGIN 34 SET @ColumnName = 35 ( 36 SELECT MIN(QUOTENAME(COLUMN_NAME)) 37 FROM INFORMATION_SCHEMA.COLUMNS 38 WHERE TABLE_SCHEMA = PARSENAME(@TableName, 2) 39 AND TABLE_NAME = PARSENAME(@TableName, 1) 40 AND DATA_TYPE IN (\u0026#39;char\u0026#39;, \u0026#39;varchar\u0026#39;, \u0026#39;nchar\u0026#39;, \u0026#39;nvarchar\u0026#39;, \u0026#39;int\u0026#39;, \u0026#39;decimal\u0026#39;) 41 AND QUOTENAME(COLUMN_NAME) \u0026gt; @ColumnName 42 ) 43 44 IF @ColumnName IS NOT NULL 45 BEGIN 46 INSERT INTO #Results 47 EXEC 48 ( 49 \u0026#39;SELECT \u0026#39;\u0026#39;\u0026#39; + @TableName + \u0026#39;.\u0026#39; + @ColumnName + \u0026#39;\u0026#39;\u0026#39;, LEFT(\u0026#39; + @ColumnName + \u0026#39;, 3630) FROM \u0026#39; + @TableName + \u0026#39; (NOLOCK) \u0026#39; + 50 \u0026#39; WHERE \u0026#39; + @ColumnName + \u0026#39; LIKE \u0026#39; + @SearchStr2 51 ) 52 END 53 END 54END 55 56SELECT ColumnName, ColumnValue FROM #Results 57 58DROP TABLE #Results همچنین می‌توان به منظور قابلیت استفاده مجدد، کد بالا را به صورت Stored Procedure نیز پیاده‌سازی نمود:\n1CREATE PROC SearchAllTables 2( 3 @SearchStr nvarchar(100) 4) 5AS 6BEGIN 7 CREATE TABLE #Results (ColumnName nvarchar(370), ColumnValue nvarchar(3630)) 8 9 SET NOCOUNT ON 10 11 DECLARE @TableName nvarchar(256), 12\t@ColumnName nvarchar(128), 13\t@SearchStr2 nvarchar(110) 14\t15 SET @TableName = \u0026#39;\u0026#39; 16 SET @SearchStr2 = QUOTENAME(\u0026#39;%\u0026#39; + @SearchStr + \u0026#39;%\u0026#39;,\u0026#39;\u0026#39;\u0026#39;\u0026#39;) 17 18 WHILE @TableName IS NOT NULL 19 BEGIN 20 SET @ColumnName = \u0026#39;\u0026#39; 21 SET @TableName = 22 ( 23 SELECT MIN(QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME)) 24 FROM INFORMATION_SCHEMA.TABLES 25 WHERE TABLE_TYPE = \u0026#39;BASE TABLE\u0026#39; 26 AND QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME) \u0026gt; @TableName 27 AND OBJECTPROPERTY( 28 OBJECT_ID( 29 QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME) 30 ), \u0026#39;IsMSShipped\u0026#39; 31 ) = 0 32 ) 33 34 WHILE (@TableName IS NOT NULL) AND (@ColumnName IS NOT NULL) 35 BEGIN 36 SET @ColumnName = 37 ( 38 SELECT MIN(QUOTENAME(COLUMN_NAME)) 39 FROM INFORMATION_SCHEMA.COLUMNS 40 WHERE TABLE_SCHEMA = PARSENAME(@TableName, 2) 41 AND TABLE_NAME = PARSENAME(@TableName, 1) 42 AND DATA_TYPE IN (\u0026#39;char\u0026#39;, \u0026#39;varchar\u0026#39;, \u0026#39;nchar\u0026#39;, \u0026#39;nvarchar\u0026#39;, \u0026#39;int\u0026#39;, \u0026#39;decimal\u0026#39;) 43 AND QUOTENAME(COLUMN_NAME) \u0026gt; @ColumnName 44 ) 45 46 IF @ColumnName IS NOT NULL 47 BEGIN 48 INSERT INTO #Results 49 EXEC 50 ( 51 \u0026#39;SELECT \u0026#39;\u0026#39;\u0026#39; + @TableName + \u0026#39;.\u0026#39; + @ColumnName + \u0026#39;\u0026#39;\u0026#39;, LEFT(\u0026#39; + @ColumnName + \u0026#39;, 3630) FROM \u0026#39; + @TableName + \u0026#39; (NOLOCK) \u0026#39; + 52 \u0026#39; WHERE \u0026#39; + @ColumnName + \u0026#39; LIKE \u0026#39; + @SearchStr2 53 ) 54 END 55 END 56 END 57 58 SELECT ColumnName, ColumnValue FROM #Results 59 DROP TABLE #Results 60END ","date":"Feb 9, 2020","img":"","permalink":"/posts/sql-server-search-in-tables/","series":[],"tags":["SQLServer"],"title":"جستجو در همه جدول‌ها در SQL Server"},{"categories":["DotNet","CSharp","SQLServer"],"content":"SQL Server به منظور ارتقا در مدل برنامه‌نویسی بانک اطلاعاتی خود از نسخه 2005 تکنولوژی SQL CLR را معرفی نمود. این تکنولوژی همچنین با اسامی CLR Integrated ،CLR Enabled و CLR Embedded نیز شناخته می‌شود. هدف آن این است که شما بتوانید اشیاء بانک اطلاعاتی از قبیل Stored Procedure ،Function ،Trigger را با استفاده از CSharp و یا VB ایجاد کرده و آن را در SQL Server مورد استفاده قرار دهید.\nتکنولوژی SQL CLR با میزبانی کردن از (dotNET Common Language Runtime) یا همان محیط زمان اجرای dotNET در SQL Server، به مدیران بانک اطلاعاتی اجازه می‌دهد تا از قابلیت‌های موجود در dotNET برای تعریف اشیاء بانک اطلاعاتی استفاده کنند. این قابلیت توسط فضاهای نام System.Data ،System.Data.Sql و Microsoft.SqlServer.Server که در اسمبلی System.Data.dll در dotNET قرار داده شده‌اند، پشتیبانی می‌گردند. ایجاد اشیاء بانک اطلاعاتی با استفاده از امکان SQL CLR، طی مراحل زیر ممکن می‌گردند:\nپیاده‌سازی کدها در CSharp یا VB در dotNET و Compile آن بارگذاری و اجرای کد Compile شده در مرحله قبل در SQL Server فعال سازی امکان SQL CLR در بانک اطلاعاتی ایجاد اسمبلی از کد مزبور در بانک اطلاعاتی ایجاد شی بانک اطلاعاتی از اسمبلی مرحله قبل پیاده‌سازی کدها در CSharp یا VB در dotNET و Compile آن به عنوان مثال کد مورد نظر خود را در کلاسی با نام StoredProcedures و در تابع SP1 نوشته و آن را Compile می‌کنیم. کد Compile شده را (StoredProcedures.dll) باید در مرحله بعد در SQL Server بارگذاری کنیم. البته کد زیر یک مثال hello world بوده و تنها به منظور آشنایی با نحوه انجام کار می‌باشد. از تمامی قابلیت‌ها و کلاس‌های موجود در dotNET می‌توان در این کلاس استفاده نمود.\n1using System; 2using System.Data; 3using Microsoft.SqlServer.Server; 4using System.Data.SqlTypes; 5 6public class StoredProcedures 7{ 8 [Microsoft.SqlServer.Server.SqlProcedure] 9 public static void SP1() 10 { 11 SqlContext.Pipe.Send(\u0026#34;Hello world!\\n\u0026#34;); 12 } 13} فعال‌سازی امکان CLR SQL در بانک اطلاعاتی امکان CLR SQL در SQL Server به صورت پیش فرض غیرفعال است و برای فعال‌سازی آن باید کد زیر را اجرا کرد:\n1sp_configure \u0026#39;show advanced options\u0026#39;, 1 2RECONFIGURE 3GO 4 5sp_configure \u0026#39;clr enabled\u0026#39;, 1 6RECONFIGURE 7GO 8 9sp_configure \u0026#39;show advanced options\u0026#39;, 0 10RECONFIGURE 11GO برای غیرفعال‌سازی هم کد زیر را باید اجرا نمود:\n1sp_configure \u0026#39;show advanced options\u0026#39;, 1 2RECONFIGURE 3GO 4 5sp_configure \u0026#39;clr enabled\u0026#39;, 0 6RECONFIGURE 7GO 8 9sp_configure \u0026#39;show advanced options\u0026#39;, 0 10RECONFIGURE 11GO برای اینکه فعال یا غیرفعال بودن SQL CLR را در SQL SERVER بررسی نماییم باید کد زیر را اجرا نمود:\n1SELECT name 2 ,CAST(value AS int) AS value_configured 3 ,CAST(value_in_use AS int) AS value_in_use 4FROM sys.configurations 5WHERE name = \u0026#39;clr enabled\u0026#39; ایجاد اسمبلی در بانک اطلاعاتی گام بعدی ایجاد اسمبلی در بانک اطلاعاتی از روی کد Compile شده است.\n1CREATE ASSEMBLY QClrIntegration 2\tFROM \u0026#39;H:\\Clr\\StoredProcedures.dll\u0026#39; 3\tWITH Permission_set = safe 4GO با توجه به کدی که نوشته‌ایم و برای کنترل دسترسی کد CLR به دیگر کدها از PERMISSION_SET استفاده می‌گردد:\nویژگی SAFE به اسمبلی‌ها اجازه می‌دهد که تنها محاسبات محلی و دسترسی به فایل‌های محلی را داشته باشد. ویژگی EXTERNAL_ACCESS مشابه ویژگی قبلی با این تفاوت که اسمبلی می‌تواند به منابع شبکه دسترسی داشته باشد. ویژگی UNSAFE اجازه دسترسی نامحدود به منابع و کدهای غیر از dotNet و مدیریت نشده (Unmanaged Code) را هم می‌دهد. برای استفاده از ویژگی UNSAFE باید ویژگی اعتماد (trustworthy) را در بانک اطلاعاتی فعال نمود. این ویژگی مشخص می‌کند که بانک اطلاعاتی به کدهای بیرونی اعتماد دارد (البته توصیه نمی‌شود). در غیر این صورت با فعال‌سازی خصوصیت UNSAFE خطا اعلام می‌شود.\n1ALTER DATABASE DB_NAME 2\tSET trustworthy ON 3GO\tبه طور کلی فعال کردن استفاده از SQL CLR سطح حملات به SQL Server را وسیع‌تر می‌کند و آن را از نظر اسمبلی‌های غیر عمدی و مخرب در معرض خطر قرار می‌دهد. با توجه به ضرورت استفاده از SQL CLR بسیاری از چک لیست‌های امنیتی فقط اسمبلی‌های ایجاد شده با دسترسی SAFE را مجاز می‌دانند و اسمبلی‌های ایجاد شده با دسترسی‌های UNSAFE و EXTERNAL_ACCESS را خطرناک می‌شمارند.\nایجاد شی بانک اطلاعاتی از اسمبلی مرحله قبل حال می‌توان از اسمبلی ایجاد شده در مرحله قبل برای ایجاد Stored Procedure و یا Function مورد نظر استفاده نمود. چون در مرحله قبل ما کلاسی از نوع Stored Procedure ایجاد کردیم، در SQL Server نیز برای استفاده از آن یک Stored Procedure ایجاد می‌کنیم.\n1CREATE PROCEDURE hello 2AS 3EXTERNAL NAME helloworld.StoredProcedures.SP1 4GO با اجرای Stored Procedure، کد نوشته شده در تابع sp1 اجرا می‌گردد:\n1EXEC hello 2 3-- Hello world! برای حذف ابتدا باید شی‌هایی که ارجاعی از اسمبلی حذف و سپس خود اسمبلی حذف گردد:\n1DROP PROCEDURE hello 2GO 3 4DROP ASSEMBLY helloworld 5GO ","date":"Feb 7, 2020","img":"","permalink":"/posts/sql-server-clr/","series":[],"tags":["SQLServer","CLR","CSharp","DotNet","SQL CLR","CLR Integrated","CLR Embedded"],"title":"استفاده از CLR در SQL Server"},{"categories":["DotNet","CSharp"],"content":"برای ایجاد و استفاده از UUID در زبان برنامه‌نویسی CSharp از ساختار Guid موجود در کتابخانه System استفاده می‌شود.\nبرای ایجاد که یک Guid در زبان برنامه‌نویسی CSharp می توان از کد زیر استفاده نمود:\n1public static Guid NewGuid() 2{ 3 return Guid.NewGuid(); 4} guid ایجاد شده در این روش از نوع و نسخه چهارم UUID است و به صورت تصادفی تولید می‌شود. برای تولید guid به صورت ترتیبی می‌توان از کد زیر استفاده نمود:\n1public static Guid NewSequentialGuid() 2{ 3 var uid = Guid.NewGuid().ToByteArray(); 4 var binDate = BitConverter.GetBytes(DateTime.UtcNow.Ticks); 5 6 var secuentialGuid = new byte[uid.Length]; 7 8 secuentialGuid[0] = uid[0]; 9 secuentialGuid[1] = uid[1]; 10 secuentialGuid[2] = uid[2]; 11 secuentialGuid[3] = uid[3]; 12 secuentialGuid[4] = uid[4]; 13 secuentialGuid[5] = uid[5]; 14 secuentialGuid[6] = uid[6]; 15 16 // set the first part of the 8th byte to \u0026#39;1100\u0026#39; so 17 // later we\u0026#39;ll be able to validate it was generated by us 18 19 secuentialGuid[7] = (byte)(0xc0 | (0xf \u0026amp; uid[7])); 20 21 // the last 8 bytes are sequential, 22 // it minimizes index fragmentation 23 // to a degree as long as there are not a large 24 // number of Secuential-Guids generated per millisecond 25 26 secuentialGuid[9] = binDate[0]; 27 secuentialGuid[8] = binDate[1]; 28 secuentialGuid[15] = binDate[2]; 29 secuentialGuid[14] = binDate[3]; 30 secuentialGuid[13] = binDate[4]; 31 secuentialGuid[12] = binDate[5]; 32 secuentialGuid[11] = binDate[6]; 33 secuentialGuid[10] = binDate[7]; 34 35 return new Guid(secuentialGuid); 36} برای بررسی رشته‌ای که حاوی guid است به ساختار guid می‌توان از کد زیر استفاده نمود:\n1public static bool IsGuid(string guidString) 2{ 3 return Guid.TryParse(guidString, out _); 4} برای بررسی اینکه آیا مقدار guid مورد نظرتان یک guid خالی است یا خیر می‌توان از کد زیر استفاده نمود:\n1public static bool IsEmptyGuid(Guid guid) 2{ 3 return guid == Guid.Empty; 4} ","date":"Feb 6, 2020","img":"","permalink":"/posts/uuid-guid-csharp/","series":[],"tags":["UUID","GUID","CSharp","DotNet"],"title":"کار با UUID در CSharp"},{"categories":["General"],"content":"UUID اختصار عبارت Universally Unique Identifier به معنای شناسه منحصر به فرد جهانی می‌باشد. به‌جای این اصطلاح از GUID که اختصار عبارت Globally Unique Identifier به معنای شناسه منحصر به فرد عمومی نیز استفاده می‌شود. GUID یک اصطلاح صنعتی است که توسط شرکت مایکروسافت برای ارائه یک شماره مرجع که در هر زمینه‌ای منحصر به فرد است، تعریف شده است در حالی که در محیط آکادمیک و در استانداردها از اصطلاح UUID استفاده شده است. هر دو اصطلاح به یک موضوع اشاره دارند و تفاوتی در استفاده ندارند.\nUUIDها یک عدد صحیح 128 بیتی هستند که اگر طبق روش‌های استاندارد تولید شوند، بدون آنکه به یک نهاد ثبت‌کننده مرکزی یا هماهنگی با سایر تولیدکننده‌های UUID برای تایید یکتایی نیاز داشته باشند، عملا یکتا خواهند بود. اگرچه احتمال اینکه یک UUID تکراری باشد، صفر نیست، اما آنقدر به صفر نزدیک است که می‌توان از آن چشم‌پوشی نمود. بنابراین هر کسی می‌تواند یک UUID ایجاد کند و از آن برای شناسایی موجودیتی استفاده کند و اطمینان داشته باشد که شناسه‌ای که تولید کرده ‌است با شناسه‌هایی که قبلا تولید شده یا بعدا تولید خواهد شد، تداخلی ندارد. اطلاعاتی که بوسیله UUIDها توسط موجودیت‌های مستقل برچسب‌گذاری شده‌اند می‌توانند بعدا با یکدیگر ادغام شده و در یک بانک اطلاعاتی قرار گیرند، بدون آنکه نیاز به از بردن تداخل‌های بین شناسه‌ها شود. UUIDها توسط Open Software Foundation (OSF) که بخشی از Distributed Computing Environment (DCE) است استانداردسازی شده‌اند. UUIDها در سال 1996 به عنوان بخشی از استاندارد ISO/IEC 11578:1996 \u0026ldquo;Information technology – Open Systems Interconnection – Remote Procedure Call (RPC)” و همچنین در سال 2005 نیز در استاندارد ITU-T Rec. X.667 | ISO/IEC 9834-8:2005 مستندسازی شده‌اند. همچنین Internet Engineering Task Force (IETF) با انتشار Standards-Track RFC 4122 که از نظر فنی با استاندارد ITU-T Rec. X.667 | ISO/IEC 9834-8 برابر است مستندات مربوط به UUIDها منتشر کرده است. در شیوه متعارف نمایش متنی، شانزده بایت یک شناسه GUID توسط 32 رقم هگزادسیمال (مبنای 16) که در 5 گروه که توسط خط فاصله از یکدیگر جدا شده‌اند در قالب 12-4-4-4-8 که در مجموع 36 کاراکتر (32 کاراکتر الفبایی و چهار خط فاصله) را تشکیل می‌دهد، نشان داده می‌شوند.\n1xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx نمونه 1\n1123E4567-E89B-12D3-A456-426614174000 نمونه 2\n1B4D0257C-BE19-4800-BA11-A09AC2561898 UUIDها دارای سه نوع و پنج نسخه می‌باشند. چهار بیت از رقمی که با M نشان داده شده ‌است، نسخه UUID و رقمی که با N نشان داده شده ‌است، نوع UUID را مشخص می‌کند.\n1xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx در نمونه 1، مقدار M برابر یک و مقدار N برابر a است، به این معنی است که نوع UUID از نوع یک، و نسخه آن نیز ۱ می‌باشد. در نمونه 2، مقدار M برابر 4 و مقدار N برابر b است، به این معنی که نوع UUID از نوع یک و نسخه آن 4 می‌باشد.\nانواع UUID نوع صفر - N = 0..7 برای سازگاری با سیستم قدیمی قالب UUID 1.5 سامانه محاسبات شبکه‌ایApollo در سال 1988 تعریف شده ‌است. در این قالب، 6 بایت اول زمان با طول 48 بیت است (تعداد واحدهای 4 میلی ثانیه از 1 ژانویه 1980 UTC). دو بایت بعدی رزرو شده است و بایت بعدی نوع آدرس‌دهی در شبکه Apollo است. هفت بایت آخر نیز یک شناسه میزبان 56 بیتی است که با توجه به نوع آدرس‌دهی تعیین می‌شود.\nنوع یک - N = 8..b این نوع در استاندارد RFC 4122/DCE 1.1 UUIDs ارجاع داده شده است و نوع رایج UUID می‌باشد.\nنوع دو - N = c..d این نوع که با عنوان GUID توسط شرکت مایکروسافت مطرح شده است اولین بار توسط این شرکت در سیستم عامل ویندوز مورد استفاده قرار گرفته است. نوع یک و دو در نمایش رشته‌ای مشابه هم هستند و تنها در بیت مربوط به نوع باهم متفاوت هستند اما در نمایش دودویی در روش نگهداری نیز باهم متفاوت هستند. در نوع یک از ترتیب بایت big-endian استفاده می‌شود در حالی که در نوع دو از ترتیب بایت little-endian استفاده شده است.\nنوع رزرو شده - N = e..f این بازه برای استفاده در آینده رزرو شده است.\nنسخه های UUID نسخه یک – زمان و آدرس MAC در این نسخه از زمان سیستم و آدرس MAC کارت شبکه که منحصر به فرد برای تولید UUID استفاده می‌شود. با داشتن UUID نسخه 1 با استخراج مقدار timestamp می‌توانید به این موضوع پی ببرید که این UUID چه زمانی تولید شده است. قالب متعارف UUIDهای مبتنی بر زمان به صورت زیر است:\nنام اندازه (بایت) طول (هگزادسیمال) محتوا time_low 4 8 عدد صحیحی که ۳۲ بیت پایینی زمان است time_mid 2 4 عدد صحیحی که ۱۶ بیت میانی زمان است time_hi_and_version 2 4 ۴ بیت پرارزش، نسخه را مشخص کرده و ۱۲ بیت دیگر ۱۲ بیت بالایی زمان است clock_seq_hi_and_res clock_seq_low 2 4 بیت‌های ۱ تا ۳ پرارزش نوع UUID و۱۳ تا ۱۵ بیت باقی مانده توالی ساعت است (clock sequence) node 6 12 شناسه گره ۴۸ بیتی نسخه دو - زمان و آدرس MAC و نسخه امنیتی DCE این نسخه به صورت خاص در استاندارد RFC 4122 تعریف نشده است و عمومیت ندارد. مشابه نسخه 1 است با این تفاوت که 4 بایت ابتدایی از timestamp با POSIX UID کاربر و بایت پر ‌ارزش توالی ساعت با POSIX UID دامنه جایگزین شده است.\nنسخه سه – MD5 hash و Namespace در این نسخه برای تولید UUID از Hash نمودن نام و شناسه Namespace توسط الگوریتم MD5 استفاده می‌شود. شناسه فضای نام می‌بایست خود منحصر به فرد باشد. مانند آدرس‌ها، نام‌های دامنه، شناسه موجودیت‌ها و نام‌های متمایز X.500 می‌توانند به عنوان فضای نام انتخاب شوند.\nنسخه چهار – تصادفی در این نسخه از اعداد تصادفی برای تولید UUID استفاده می‌شود. از 128 بیت، 6 بیت برای نوع و نسخه UUID رزرو شده و مابقی 122 بیت به صورت تصادفی مقدار می‌گیرند که 2 به توان 122 احتمال را شامل می‌شود. از روش های متفاوتی برای تولید اعداد تصادفی در این نسخه استفاده می‌شود و استاندارد مشخصی در این زمینه وجود ندارد.\nنسخه پنج - SHA-1 hash و Namespace مشابه نسخه 3 است با این تفاوت که از الگوریتم SHA-1 به جای MD5 برای Hash نمودن استفاده می‌شود.\nUUID خالی یا Nil UUID برای UUID یک مقدار خالی یا تهی در نظر گرفته شده است که مقدار آن 00000000-0000-0000-0000-000000000000 می‌باشد.\nصحت یکتایی UUID برخورد (Collisions) هنگامی رخ می‌دهد که یک UUID بیش از یک بار ایجاد شده و به مراجع مختلف اختصاص داده شود. در مورد UUIDهای نسخه 1 و نسخه 2 که با استفاده از آدرس‌های MAC کارت‌های شبکه که منحصر به فرد هستند ساخته شده‌اند، فقط زمانی که پیاده‌سازی استانداردها متفاوت باشد یا ایراداتی در آن وجود داشته باشد احتمال برخورد وجود دارد.\nبرخلاف نسخه 1 و نسخه 2 UUID که از آدرس‌های MAC منحصر به فرد کارت‌های شبکه استفاده می‌کنند، در نسخه 1 و 2 UUID تصادفی و نسخه 3 و 5 که مبتنی بر Hash هستند و نسخه 4 UUID تصادفی، احتمال برخورد وجود دارد. البته با احتمال بسیار کمی که به طور معمول قابل چشم پوشی است. این احتمال را می‌توان دقیقا بر اساس تجزیه و تحلیل پارادوکس تولد محاسبه کرد.\nبه عنوان مثال، تعداد UUIDهای نسخه 4 تصادفی که باید ایجاد شوند تا به احتمال 50٪ حداقل یک برخورد باید تولید شود برابر 2.71 کوئین تیلیون است. این عدد معادل تولید 1 میلیارد UUID در ثانیه برای حدود 85 سال است. فایلی که حاوی این تعداد UUID باشد، با 16 بایت در هر UUID، تقریباً 45 اگزا بایت خواهد بود. احتمال یافتن نسخه تکراری در نسخه 103 تریلیون نسخه 4 UUID یک در میلیارد است.\n","date":"Feb 5, 2020","img":"","permalink":"/posts/uuid-guid-info/","series":[],"tags":["UUID","GUID"],"title":"UUID چیست؟"},{"categories":["DotNet","CSharp"],"content":"برای کار با آدرس‌های IPv4 و IPv6 در CSharp از کتابخانه System.Net و کلاس IPAddress استفاده می‌شود.\nبه منظور اعتبارسنجی آدرس‌های IP می‌توان از کد زیر استفاده نمود:\n1public static bool IsValidIp(string address) 2{ 3 return IPAddress.TryParse(address, out _); 4} به منظور تشخیص نسخه‌ی آدرس‌های IP می‌توان از کد زیر استفاده نمود:\n1public static IpVersion GetIpVersion(string address) 2{ 3 if (IPAddress.TryParse(address, out var ipAddress)) 4 { 5 if(ipAddress.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork) 6 { 7 return IpVersion.IPv4; 8 } 9 else if(ipAddress.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6) 10 { 11 return IpVersion.IPv6; 12 } 13 } 14 15 return IpVersion.Unknown; 16} 17\t18public enum IpVersion 19{ 20 Unknown = -1, 21 IPv4, 22 IPv6 23} آدرس Loopback یک آدرس IP ویژه است که برای آزمایش کارت‌های شبکه، ارتباطات و انتقال در یک کارت شبکه محلی و برنامه‌های کاربردی استفاده می‌شود. این آدرس IP مربوط به Loopback Interface نرم‌افزار کارت شبکه است که هیچ سخت‌افزاری با آن ارتباط ندارد و نیازی به اتصال فیزیکی به شبکه ندارد. برای تشخیص اینکه یک IP از نوع Loopback است یا خیر می‌توان از کد زیر استفاده نمود:\n1public static bool IsLoopback(string address) 2{ 3 if (address == \u0026#34;localhost\u0026#34;) 4 return true; 5 6 if (IPAddress.TryParse(address, out var ipAddress)) 7 { 8 if (ipAddress == IPAddress.Loopback || ipAddress == IPAddress.IPv6Loopback) 9 return true; 10 } 11 12 return false; 13} ","date":"Jan 4, 2020","img":"","permalink":"/posts/ip-csharp/","series":[],"tags":["IP","IPHelper","CSharp","DotNet"],"title":"کار با آدرس‌های IP در CSharp"},{"categories":["General"],"content":"IP اختصار عبارت Internet Protocol است که مدل فنی ارسال و دریافت بسته‌ها در اینترنت را به همراه آدرس فرستنده و گیرنده در شبکه‌ی اینترنت یا هر شبکه‌ی کامپیوتری مشخص می‌کند. در حال حاضر دو نسخه برای IP وجود دارد که شامل IPv4 و IPv6 است.\nIPv6 که Internet Protocol Next Generation نیز خوانده می‌شود، جدیدترین پروتکل اینترنت برای اختصاص آدرس IP است که برای تکمیل و در نهایت جایگزین شدن IPV4 در نظر گرفته شده است. در حال حاضر تا زمان مقتضی شاهد استفاده از هر دو پروتکل به‌صورت هم‌زمان خواهیم بود تا اینکه در نهایت IPv6 به‌صورت کامل جای این پروتکل را بگیرد. IPv6 به این علت طراحی شده است تا علاوه بر داشتن آدرس‌های بیشتر برای اتصال دستگاه‌های بیشتر در مقایسه با IPv4، ظرفیت انتقال اطلاعات در شبکه اینترنت یا همان ترافیک را افزایش دهد. IPv4 یک آدرس اینترنتی 32 بیتی است که به‌صورت اعداد ده‌دهی (دستگاه اعداد مبنای ۱0) در قالب یک رشته نمایش داده می‌شود. یک آدرس اینترنتی مبتنی بر IPv4 به‌صورت چهار دسته (Octet) 8 بیتی نوشته می‌شود که توسط یک نقطه از هم جدا می‌شوند. هر یک از چهار دسته عدد سه‌تایی می‌تواند مقادیر صفر تا 255 را داشته باشد. پس برای هر بخش می توان 256 رقم (2 به توان 8) را در نظر گرفت که با این حساب 2 به توان 32 یا 4294967296 رقم خواهیم داشت. برای مثال آدرس زیر یک آدرس اینترنتی مبتنی بر IPv4 است.\n1172.16.110.1 IPv6 یک آدرس اینترنتی 128 بیتی است که به‌صورت اعداد هگزادسیمال استاندارد (دستگاه اعداد مبنای 16) در قالب یک رشته نمایش داده می‌شود. یک آدرس اینترنتی مبتنی بر IPv6 به‌صورت هشت دسته (Octet) 16 بیتی نوشته می‌شود که توسط یک کالِن از هم جدا می‌شوند. هر یک از هشت دسته 8 بیتی می‌تواند مقادیر 0000 تا FFFF را داشته باشد. پس برای هر بخش می‌توان 65,536 رقم (2 به توان 16) را در نظر گرفت که با این حساب 2 به توان 128 یا 340,282,366,920,938,463,463,374,607,431,768,211,456 عدد خواهیم داشت که حدود 7,922,816,251,426,433,759,354 برابر بیشتر از IPv4 می‌باشد. برای مثال آدرس زیر یک آدرس اینترنتی مبتنی بر IPv6 است.\n165b3:b834:45a3:0000:0000:762e:0270:5224 در IPv6 بخش‌هایی که تمام رقم‌های آن صفر می‌باشند را می‌توان حذف نمود و به جای آن‌ها از کاراکتر : استفاده کرد. به عنوان مثال آدرس‌های زیر مشابه هم هستند:\n12001:cdba:0000:0000:0000:0000:3257:9652 2 32001:cdba:0:0:0:0:3257:9652 4 52001:cdba::3257:9652 ","date":"Jan 3, 2020","img":"","permalink":"/posts/ip-info/","series":[],"tags":["IP"],"title":"آدرس IP چیست؟"},{"categories":["SQLServer"],"content":"با توجه به نسخه SQL Server روش جستجو و بازگرداندن لیستی از تمام جدول‌های ایجاد شده توسط کاربر کمی متفاوت است. در این مطلب به طور خلاصه پرس‌و‌جوهایی را بررسی خواهیم کرد که می‌توانند برای بازیابی لیست جدول‌ها در همه نسخه‌ها استفاده شوند.\nنسخه 2000 برای نسخه‌های قدیمی‌تر SQL Server (مانند SQL Server 2000، اگرچه این روش در SQL Server 2005 برای سازگاری با نسخه‌های قبلی نیز پشتیبانی می‌شود)، باید از یک View به نام SYS.SYSOBJECTS استفاده نمایید. این View شامل یک ردیف برای هر شی می‌باشد که در بانک اطلاعاتی ایجاد شده است، از جمله Viewها، stored procedureها و جدول‌ها. جدول‌هایی که کاربر ایجاده کرده است نیز قابل تفکیک از جدول‌های سیستمی هستند.\nدر SYSOBJECTS ستون‌های دیگری نیز وجود دارد زیرا باید اطلاعاتی در مورد هر چیزی که در طول زمان به بانک اطلاعاتی اضافه شده است را در خود نگهداری نماید. بنابراین، برای یافتن لیستی از جدول‌های ایجاد شده توسط کاربر (و تفکیک آن از جدول‌های سیستم)، باید نتایجی را پیدا کنیم که در آن ستون xtype (که نوع شی را برای آن ردیف مشخص می‌کند) برابر با مقدار U است که به معنای جدول‌های کاربر است. دستور TSQL حاصل باید به شکل زیر باشد:\n1SELECT 2 * 3FROM 4 SYSOBJECTS 5WHERE 6 xtype = \u0026#39;U\u0026#39;; 7GO از آنجایی که SYSOBJECTS بخشی از فضای نام SYS است، هنگام پرس‌و‌جو از SYSOBJECTS، تعیین اینکه SYSOBJECTS بخشی از فضای نام سراسری SYS است، غیر ضروری است، بنابراین می‌توانیم آن را همانطور که در مثال بالا نشان داده شده است حذف نماییم.\nمثال بالا لیستی از نتایج تمامی جدول‌ها ایجاد شده توسط کاربر را باز می‌گرداند. از آنجایی که تعداد ستون‌‌هایی که هنگام پرس‌و‌جو از همه ستون‌ها بازگردانده می‌شود بسیار زیاد است، ممکن است بخواهید نتایج را تنها با مشاهده ستون نام و cdate (تاریخ ایجاد) محدود کنید:\n1SELECT 2 name, 3 crdate 4FROM 5 SYSOBJECTS 6WHERE 7 xtype = \u0026#39;U\u0026#39;; 8GO نسخه 2005 به بالا فهرست کردن نام تمام جدول‌ها در SQL Server در نسخه‌های 2005 به بالا با استفاده از یک View به نام INFORMATION_SCHEMA امکان‌پذیر است که به طور خودکار در SQL Server ساخته می‌شود. این View به شما این امکان را می‌دهد که به راحتی طیف گسترده‌ای از metadata از اشیاء موجود در SQL Server را مشاهده نمایید از جمله اطلاعاتی در مورد ستون‌ها، stored procedureها، و حتی جدول‌ها. در هنگام استفاده از این View چهار ستون بازگردانده می‌شود، که مهمترین ستون آن TABLE_TYPE است که تعیین می‌کند موجودیت آن سطر یک جدول یا یک View است.\nبرای برگرداندن همه جدول‌ها و Viewها در یک پرس‌و‌جو، عبارت TSQL زیر را اجرا کنید:\n1SELECT 2 * 3FROM 4 INFORMATION_SCHEMA.TABLES; 5GO برای برگرداندن همه جدول‌ها و Viewهای یک بانک اطلاعاتی در یک پرس‌و‌جو، عبارت TSQL زیر را اجرا کنید:\n1SELECT 2 * 3FROM 4 databaseName.INFORMATION_SCHEMA.TABLES; 5GO اگر می‌خواهید فقط جدول‌های کاربر را مشاهده نمایید عبارت TSQL زیر را اجرا کنید:\n1SELECT 2 * 3FROM 4 databaseName.INFORMATION_SCHEMA.TABLES 5WHERE 6 TABLE_TYPE = \u0026#39;BASE TABLE\u0026#39;; 7GO ","date":"Aug 1, 2019","img":"","permalink":"/posts/sql-server-show-all-tables/","series":[],"tags":["SQLServer"],"title":"نمایش لیست همه جدول‌ها در SQL Server"},{"categories":null,"content":"من آرمان حسن پور هستم. از سال 1390 شروع به برنامه‌نویسی کردم. با زبان‌های برنامه‌نویسی زیادی کار کردم ولی بیشتر از زبان، توانایی حل مسئله برام ارزشمند بوده و هست. بیشتر فعالیتم در حوزه‌های مالی و بانکی بوده و همچنین در مدیریت بانک‌های اطلاعاتی دارای مهارت هستم. علاقه‌مند به یادگیری و کسب مهارت در حوزه‌های جدید فناوری اطلاعات هستم و تلاش می‌کنم که خودمو به روز نگه داشته باشم.\n","date":"Feb 28, 2019","img":"","permalink":"/about/","series":null,"tags":null,"title":"در مورد من"},{"categories":["Oracle"],"content":"در برخی از سناریوها نیاز به نمایش خروجی چند مقدار به صورت یک مقدار با یک جداکننده مانند کاما داریم. در Oracle می‌توان از تابع LISTAGG برای تبدیل نتایج پرس‌و‌جو به صورت یک مقدار جداشده با کاما استفاده نمود.\nبه طور مثال پرس‌و‌جوی زیر نام قاره‌ها را از جدول regions باز می‌گرداند.\n1SELECT region_name 2FROM regions; نتیجه:\n1REGION_NAME 2------------------------ 3Americas 4Asia 5Middle East and Africa این پرس‌و‌جو چهار سطر مختلف به عنوان نتیجه را باز می‌گرداند. اما اگر بخواهیم این چهار سطر را به صورت یک مقدار جدا شده با کاما نمایش دهیم می‌توانیم آن را به صورت زیر انجام دهیم:\n1SELECT LISTAGG(region_name, \u0026#39;, \u0026#39;) 2FROM regions; نتیجه:\n1LISTAGG(LAST_NAME,\u0026#39;,\u0026#39;) 2----------------------------------------------- 3Europe, Americas, Asia, Middle East and Africa تابع LISTAGG دو مقدار را به عنوان ورودی دریافت می‌نماید. مقدار اول نام ستون و مقدار دوم جدا کننده مورد نظر می‌باشد که در این مثال کاراکتر کاما است. مقدار دوم اختیاری است و اگر داده نشود بدون جدا کننده مقادیر بهم چسبانده می‌شوند.\nامکان استفاده از عبارت DISTINCT در تابع LISTAGG به منظور حذف مقادیر تکراری نیز وجود دارد.\n1SELECT LISTAGG(DISTINCT region_id, \u0026#39;,\u0026#39;) 2FROM countries نتیجه:\n1LISTAGG(DISTINCT region_id, \u0026#39;,\u0026#39;) 2-------------------------------------------- 31,2,3,4 به منظور مرتب سازی نتایج در تابع LISTAGG می‌توان از عبارت WITHIN GROUP (ORDER BY\u0026hellip;) استفاده نمود.\n1SELECT LISTAGG(region_name, \u0026#39;,\u0026#39;) WITHIN GROUP (ORDER BY region_name ASC) 2FROM regions; نتیجه:\n1LISTAGG(region_name, \u0026#39;,\u0026#39;) 2-------------------------------------------- 3Americas,Asia,Europe,Middle East and Africa از تابع LISTAGG می توان در یک پرس‌و‌جو گروه‌بندی شده نیز استفاده نمود.\n1SELECT 2 region_id, 3 LISTAGG(country_id, \u0026#39;, \u0026#39;) WITHIN GROUP (ORDER BY country_id ASC) AS \u0026#34;Countries\u0026#34; 4FROM countries 5GROUP BY region_id 6ORDER BY region_id; نتیجه:\n1REGION_ID\tCountries 2------------------------------------------------ 31\tBE, CH, DE, DK, FR, IT, NL, UK 42\tAR, BR, CA, MX, US 53\tAU, CN, HK, IN, JP, SG 64\tEG, IL, KW, NG, ZM, ZW ","date":"Feb 5, 2019","img":"","permalink":"/posts/oracle-lisagg/","series":[],"tags":["Oracle","LISTAGG","Comma Separated List"],"title":"نمایش نتایج پرس‌و‌جوها به صورت یک مقدار جداشده با کاما در Oracle"},{"categories":["General"],"content":"به منظور استفاده از جداول نمونه یکسان در مطالب این وبلاگ تصمیم گرفتم در یک مطلب جداگانه اسکریپت‌های مربوط به ایجاد جداول و ثبت داده‌های پیش فرض آن را برای هر نوع بانک اطلاعاتی قرار دهم. در این مطلب اسکریپت مربوط به بانک اطلاعاتی Oracle قرار داده شده است.\nجدول regions 1CREATE TABLE regions ( 2 region_id NUMBER(10) PRIMARY KEY, 3 region_name VARCHAR2(25) DEFAULT NULL 4); 5 6INSERT INTO regions(region_id,region_name) VALUES (1,\u0026#39;Europe\u0026#39;); 7INSERT INTO regions(region_id,region_name) VALUES (2,\u0026#39;Americas\u0026#39;); 8INSERT INTO regions(region_id,region_name) VALUES (3,\u0026#39;Asia\u0026#39;); 9INSERT INTO regions(region_id,region_name) VALUES (4,\u0026#39;Middle East and Africa\u0026#39;); جدول countries 1CREATE TABLE countries ( 2\tcountry_id CHAR(2) PRIMARY KEY, 3\tcountry_name VARCHAR2(40) DEFAULT NULL, 4\tregion_id NUMBER(10) NOT NULL, 5\tFOREIGN KEY (region_id) REFERENCES regions (region_id) ON DELETE CASCADE 6); 7 8INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;AU\u0026#39;,\u0026#39;Australia\u0026#39;,3); 9INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;AR\u0026#39;,\u0026#39;Argentina\u0026#39;,2); 10INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;BE\u0026#39;,\u0026#39;Belgium\u0026#39;,1); 11INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;BR\u0026#39;,\u0026#39;Brazil\u0026#39;,2); 12INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;CA\u0026#39;,\u0026#39;Canada\u0026#39;,2); 13INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;CH\u0026#39;,\u0026#39;Switzerland\u0026#39;,1); 14INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;CN\u0026#39;,\u0026#39;China\u0026#39;,3); 15INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;DE\u0026#39;,\u0026#39;Germany\u0026#39;,1); 16INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;DK\u0026#39;,\u0026#39;Denmark\u0026#39;,1); 17INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;EG\u0026#39;,\u0026#39;Egypt\u0026#39;,4); 18INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;FR\u0026#39;,\u0026#39;France\u0026#39;,1); 19INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;HK\u0026#39;,\u0026#39;HongKong\u0026#39;,3); 20INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;IL\u0026#39;,\u0026#39;Israel\u0026#39;,4); 21INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;IN\u0026#39;,\u0026#39;India\u0026#39;,3); 22INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;IT\u0026#39;,\u0026#39;Italy\u0026#39;,1); 23INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;JP\u0026#39;,\u0026#39;Japan\u0026#39;,3); 24INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;KW\u0026#39;,\u0026#39;Kuwait\u0026#39;,4); 25INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;MX\u0026#39;,\u0026#39;Mexico\u0026#39;,2); 26INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;NG\u0026#39;,\u0026#39;Nigeria\u0026#39;,4); 27INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;NL\u0026#39;,\u0026#39;Netherlands\u0026#39;,1); 28INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;SG\u0026#39;,\u0026#39;Singapore\u0026#39;,3); 29INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;UK\u0026#39;,\u0026#39;United Kingdom\u0026#39;,1); 30INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;US\u0026#39;,\u0026#39;United States of America\u0026#39;,2); 31INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;ZM\u0026#39;,\u0026#39;Zambia\u0026#39;,4); 32INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;ZW\u0026#39;,\u0026#39;Zimbabwe\u0026#39;,4); ","date":"Jan 2, 2017","img":"","permalink":"/posts/oracle-sample-tables/","series":[],"tags":["Oracle"],"title":"نمونه جدول‌های Oracle"},{"categories":["General"],"content":"به منظور ترجمه یکسان کلمات انگلیسی در مطالب این وبلاگ تصمیم گرفتم در یک مطلب جداگانه ترجمه کلمات (یا معادل فارسی مورد استفاده) را قرار دهم.\nassembly - اسمبلی checklist - چک لیست class - کلاس clause - عبارت code - کد comma - کاما database - بانک اطلاعاتی namespace - فضای نام object - شی query - پرس‌و‌جو\n","date":"Jan 1, 2017","img":"","permalink":"/posts/dict/","series":[],"tags":[],"title":"واژه نامه"},{"categories":null,"content":"","date":"Jan 1, 0001","img":"","permalink":"/contact/","series":null,"tags":null,"title":"تماس با من"}]