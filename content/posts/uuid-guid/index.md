+++
author = "آرمان حسن پور"
title = "کار با UUID در زبان‌های برنامه‌نویسی" 
date = 2020-02-05T15:42:57+08:00
featured = false
comment = false
toc = false
reward = false
pinned = false
categories = [
	"DotNet", "CSharp"
]
tags = [
    "UUID", "GUID", "CSharp", "DotNet"
]
series = []
images = []
+++

UUID اختصار عبارت Universally Unique Identifier به معنای شناسه منحصر به فرد جهانی می‌باشد. به‌جای این اصطلاح از GUID که اختصار عبارت Globally Unique Identifier به معنای شناسه منحصر به فرد عمومی نیز استفاده می‌شود. GUID یک اصطلاح صنعتی است که توسط شرکت مایکروسافت برای ارائه یک شماره مرجع که در هر زمینه‌ای منحصر به فرد است، تعریف شده است در حالی که در محیط آکادمیک و در استانداردها از اصطلاح UUID استفاده شده است. هر دو اصطلاح به یک موضوع اشاره دارند و تفاوتی در استفاده ندارند.
<br>
UUIDها یک عدد صحیح 128 بیتی هستند که اگر طبق روش‌های استاندارد تولید شوند، بدون آنکه به یک نهاد ثبت‌کننده مرکزی یا هماهنگی با سایر تولیدکننده‌های UUID برای تایید یکتایی نیاز داشته باشند، عملا یکتا خواهند بود. اگرچه احتمال اینکه یک UUID تکراری باشد، صفر نیست، اما آنقدر به صفر نزدیک است که می‌توان از آن چشم‌پوشی نمود.
<br>
بنابراین هر کسی می‌تواند یک UUID ایجاد کند و از آن برای شناسایی موجودیتی استفاده کند و اطمینان داشته باشد که شناسه‌ای که تولید کرده ‌است با شناسه‌هایی که قبلا تولید شده یا بعدا تولید خواهد شد، تداخلی ندارد. اطلاعاتی که بوسیله UUIDها توسط موجودیت‌های مستقل برچسب‌گذاری شده‌اند می‌توانند بعدا با یکدیگر ادغام شده و در یک پایگاه داده قرار گیرند، بدون آنکه نیاز به از بردن تداخل‌های بین شناسه‌ها شود.
<br>
UUIDها توسط Open Software Foundation (OSF) که بخشی از Distributed Computing Environment (DCE) است استانداردسازی شده‌اند. UUIDها در سال 1996 به عنوان بخشی از استاندارد ISO/IEC 11578:1996 "Information technology – Open Systems Interconnection – Remote Procedure Call (RPC)” و همچنین در سال 2005 نیز در استاندارد ITU-T Rec. X.667 | ISO/IEC 9834-8:2005 مستندسازی شده‌اند. همچنین Internet Engineering Task Force (IETF) با انتشار Standards-Track RFC 4122 که از نظر فنی با استاندارد ITU-T Rec. X.667 | ISO/IEC 9834-8 برابر است مستندات مربوط به UUIDها منتشر کرده است.
در شیوه متعارف نمایش متنی، شانزده بایت یک شناسه GUID توسط 32 رقم هگزادسیمال (مبنای 16) که در 5 گروه که توسط خط فاصله از یکدیگر جدا شده‌اند در قالب 12-4-4-4-8 که در مجموع 36 کاراکتر (32 کاراکتر الفبایی و چهار خط فاصله) را تشکیل می‌دهد، نشان داده می‌شوند. 
```Text
xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
```
نمونه 1
```Text
123E4567-E89B-12D3-A456-426614174000
```
نمونه 2
```Text
B4D0257C-BE19-4800-BA11-A09AC2561898
```
UUIDها دارای سه نوع و پنج نسخه می‌باشند. چهار بیت از رقمی که با M نشان داده شده ‌است، نسخه UUID و رقمی که با N نشان داده شده ‌است، نوع UUID را مشخص می‌کند.
```Text
xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
```
در نمونه 1، مقدار M برابر یک و مقدار N برابر a است، به این معنی است که نوع UUID از نوع یک، و نسخه آن نیز ۱ می‌باشد.
در نمونه 2،  مقدار M برابر 4 و مقدار N برابر b است، به این معنی که نوع UUID از نوع یک و نسخه آن 4 می باشد.

## انواع UUID

### نوع صفر - N = 0..7
برای سازگاری با سیستم قدیمی قالب UUID 1.5 سامانه محاسبات شبکه‌ایApollo  در سال 1988 تعریف شده ‌است. در این قالب، 6 بایت اول زمان با طول 48 بیت است (تعداد واحدهای 4 میلی ثانیه از 1 ژانویه 1980 UTC). دو بایت بعدی رزرو شده است و بایت بعدی نوع آدرس‌دهی در شبکه Apollo است. هفت بایت آخر نیز یک شناسه میزبان 56 بیتی است که با توجه به نوع آدرس‌دهی تعیین می‌شود.

### نوع یک - N = 8..b
این نوع در استاندارد RFC 4122/DCE 1.1 UUIDs ارجاع داده شده است و نوع رایج UUID می باشد.

### نوع دو - N = c..d
این نوع که با عنوان GUID توسط شرکت مایکروسافت مطرح شده است اولین بار توسط این شرکت در سیستم عامل ویندوز مورد استفاده قرار گرفته است. نوع یک و دو در نمایش رشته‌ای مشابه هم هستند و تنها در بیت مربوط به نوع باهم متفاوت هستند اما در نمایش دودویی در روش نگهداری نیز باهم متفاوت هستند. در نوع یک از ترتیب بایت big-endian استفاده می‌شود در حالی که در نوع دو از ترتیب بایت little-endian استفاده شده است.

### نوع رزرو شده - N = e..f
این بازه برای استفاده در آینده رزرو شده است.


## نسخه های UUID

### نسخه یک – زمان و آدرس MAC
در این نسخه از زمان سیستم و آدرس MAC کارت شبکه که منحصر به فرد برای تولید UUID استفاده می‌شود. با داشتن UUID نسخه 1 با استخراج مقدار timestamp می‌توانید به این موضوع پی ببرید که این UUID چه زمانی تولید شده است. قالب متعارف UUIDهای مبتنی بر زمان به صورت زیر است:
| نام | اندازه (بایت) | طول (هگزادسیمال) | محتوا
|:---|:---|:---|:---
| time_low | 4 | 8 | عدد صحیحی که ۳۲ بیت پایینی زمان است
| time_mid | 2 | 4 | عدد صحیحی که ۱۶ بیت میانی زمان است
| time_hi_and_version | 2 | 4 | ۴ بیت پرارزش، نسخه را مشخص کرده و ۱۲ بیت دیگر ۱۲ بیت بالایی زمان است
| clock_seq_hi_and_res clock_seq_low | 2 | 4 | بیت‌های ۱ تا ۳ پرارزش نوع UUID و۱۳ تا ۱۵ بیت باقی مانده توالی ساعت است (clock sequence)
| node | 6 | 12 | شناسه گره ۴۸ بیتی

### نسخه دو - زمان و آدرس MAC و نسخه امنیتی DCE
این نسخه به صورت خاص در استاندارد RFC 4122 تعریف نشده است و عمومیت ندارد. مشابه نسخه 1 است با این تفاوت که 4 بایت ابتدایی از timestamp با POSIX UID کاربر و بایت پر ‌ارزش توالی ساعت با POSIX UID دامنه جایگزین شده است.

### نسخه سه – MD5 hash و Namespace
در این نسخه برای تولید UUID از Hash نمودن نام و شناسه Namespace توسط الگوریتم MD5 استفاده می‌شود. شناسه فضای نام می‌بایست خود منحصر به فرد باشد. مانند آدرس‌ها، نام‌های دامنه، شناسه موجودیت‌ها و نام‌های متمایز X.500 می‌توانند به عنوان فضای نام انتخاب شوند.

### نسخه چهار – تصادفی
در این نسخه از اعداد تصادفی برای تولید UUID استفاده می‌شود. از 128 بیت، 6 بیت برای نوع و نسخه UUID رزرو شده و مابقی 122 بیت به صورت تصادفی مقدار می‌گیرند که 2 به توان 122 احتمال را شامل می شود. از روش های متفاوتی برای تولید اعداد تصادفی در این نسخه استفاده می‌شود و استاندارد مشخصی در این زمینه وجود ندارد. 

### نسخه پنج - SHA-1 hash و Namespace
مشابه نسخه 3 است با این تفاوت که از الگوریتم SHA-1 به جای MD5 برای Hash نمودن استفاده می‌شود.

### UUID خالی یا Nil UUID
برای UUID یک مقدار خالی یا تهی در نظر گرفته شده است که مقدار آن 00000000-0000-0000-0000-000000000000 می‌باشد.

## صحت یکتایی UUID

برخورد (Collisions) هنگامی رخ می‌دهد که یک UUID بیش از یک بار ایجاد شده و به مراجع مختلف اختصاص داده شود. در مورد UUIDهای نسخه 1 و نسخه 2 که با استفاده از آدرس‌های MAC کارت‌های شبکه که منحصر به فرد هستند ساخته شده‌اند، فقط زمانی که پیاده‌سازی استانداردها متفاوت باشد یا ایراداتی در آن وجود داشته باشد احتمال برخورد وجود دارد.

برخلاف نسخه 1 و نسخه 2 UUID که از آدرس‌های MAC منحصر به فرد کارت‌های شبکه استفاده می‌کنند، در نسخه 1 و 2 UUID تصادفی و نسخه 3 و 5 که مبتنی بر Hash هستند و نسخه 4 UUID تصادفی، احتمال برخورد وجود دارد. البته با احتمال بسیار کمی که به طور معمول قابل چشم پوشی است. این احتمال را می‌توان دقیقا بر اساس تجزیه و تحلیل پارادوکس تولد محاسبه کرد. 

به عنوان مثال، تعداد UUIDهای نسخه 4 تصادفی که باید ایجاد شوند تا به احتمال 50٪ حداقل یک برخورد باید تولید شود برابر 2.71 کوئین تیلیون است. این عدد معادل تولید 1 میلیارد UUID در ثانیه برای حدود 85 سال است. فایلی که حاوی این تعداد UUID باشد، با 16 بایت در هر UUID، تقریباً 45 اگزا بایت خواهد بود. احتمال یافتن نسخه تکراری در نسخه 103 تریلیون نسخه 4 UUID یک در میلیارد است.

## UUID در CSharp
برای ایجاد و استفاده از UUID در زبان برنامه‌نویسی CSharp از ساختار Guid موجود در کتابخانه System استفاده می شود:
```csharp
    public static Guid NewGuid()
    {
        return Guid.NewGuid();
    }
```

guid ایجاد شده در این روش از نوع و نسخه چهارم UUID است و به صورت تصادفی تولید می‌شود. برای تولید guid به صورت ترتیبی می‌توان از کد زیر استفاده نمود:
```csharp
    public static Guid NewSequentialGuid()
    {
        var uid = Guid.NewGuid().ToByteArray();
        var binDate = BitConverter.GetBytes(DateTime.UtcNow.Ticks);

        var secuentialGuid = new byte[uid.Length];

        secuentialGuid[0] = uid[0];
        secuentialGuid[1] = uid[1];
        secuentialGuid[2] = uid[2];
        secuentialGuid[3] = uid[3];
        secuentialGuid[4] = uid[4];
        secuentialGuid[5] = uid[5];
        secuentialGuid[6] = uid[6];

        // set the first part of the 8th byte to '1100' so     
        // later we'll be able to validate it was generated by us   

        secuentialGuid[7] = (byte)(0xc0 | (0xf & uid[7]));

        // the last 8 bytes are sequential,    
        // it minimizes index fragmentation   
        // to a degree as long as there are not a large    
        // number of Secuential-Guids generated per millisecond  

        secuentialGuid[9] = binDate[0];
        secuentialGuid[8] = binDate[1];
        secuentialGuid[15] = binDate[2];
        secuentialGuid[14] = binDate[3];
        secuentialGuid[13] = binDate[4];
        secuentialGuid[12] = binDate[5];
        secuentialGuid[11] = binDate[6];
        secuentialGuid[10] = binDate[7];

        return new Guid(secuentialGuid);
    }
```

برای بررسی رشته‌ای که حاوی guid است به ساختار guid می‌توان از کد زیر استفاده نمود:
```csharp
    public static bool IsGuid(string guidString)
    {
        return Guid.TryParse(guidString, out _);
    }
```

برای بررسی اینکه آیا مقدار guid مورد نظرتان یک guid خالی است یا خیر می‌توان از کد زیر استفاده نمود:
```csharp
    public static bool IsEmptyGuid(Guid guid)
    {
        return guid == Guid.Empty;
    }
```